#ifndef __LOWI_RESPONSE_H__
#define __LOWI_RESPONSE_H__

/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*

        LOWI Response Interface Header file

GENERAL DESCRIPTION
  This file contains the structure definitions and function prototypes for
  LOWIResponse

Copyright (c) 2012 Qualcomm Atheros, Inc.
  All Rights Reserved.
  Qualcomm Atheros Confidential and Proprietary.

Export of this technology or software is regulated by the U.S. Government.
Diversion contrary to U.S. law prohibited.
=============================================================================*/
#if APSS
#include <inc/lowi_const.h>
#include <inc/lowi_scan_measurement.h>
#else
#include "lowi_const.h"
#include "vector.h"
#include "lowi_service_v01.h"
#include "lowi_ssid.h"
#include "lowi_mac_address.h"
#include "lowi_scan_measurement.h"
#endif

namespace qc_loc_fw
{

#define MAX_APS_ALLOWED 75

/**
 * Base class for Response
 */
class LOWIResponse
{
protected:
  static const char* const TAG;

  /** Supported structure version
   *  This version depends on the QMI service major version */
  eSupportedServiceVersion mResponseVersion;

private:

  uint32 requestId;
  uint32 clientId;

public:
  /** Type of Response*/
  enum eResponseType
  {
    RESPONSE_TYPE_UNKNOWN = 0,
    DISCOVERY_SCAN,
    RANGING_SCAN,
    CAPABILITY,
    RESET_CACHE,
    ASYNC_DISCOVERY_SCAN_RESULTS,
    WLAN_EVENTS,
    WLAN_EVENTS_QUERY,
    BATCHING_SUBSCRIPTION,
    BATCHING_RESULTS,
    BGSCAN_SUBSCRIPTION,
    BGSCAN_RESULTS,
    EXT_RANGING_RESULTS_REQ
  };

  /**
   * Defines status of the Scan Request.
   */
  enum eScanStatus
  {
    SCAN_STATUS_UNKNOWN = 0,
    /** Measurements were obtained successfully from the WLAN driver.
     * Note that SUCCESS does not guarantee that there is at least one
     * measurement in this packet. It is possible to have zero measurement
     * and a SUCCESS; if there are no APs in the vicinity.*/
    SCAN_STATUS_SUCCESS,
    /** Indicates that the number of pending clients have reached the maximum*/
    SCAN_STATUS_BUSY,
    /** Unable to initiate request to driver*/
    SCAN_STATUS_DRIVER_ERROR,
    /** Unable to get response from driver*/
    SCAN_STATUS_DRIVER_TIMEOUT,
    /** There is an internal error condition that causes
     * LOWI unable to provide any measurements*/
    SCAN_STATUS_INTERNAL_ERROR,
    /** Invalid request*/
    SCAN_STATUS_INVALID_REQ,
    /** Request not supported */
    SCAN_STATUS_NOT_SUPPORTED,
    /** Wifi not enabled */
    SCAN_STATUS_NO_WIFI,
    /** No WLS service */
    SCAN_STATUS_NO_WLS
  };

  /**
   * Constructor
   * @param eSupportedServiceVersion Supported structure version. This version depends on
   *              the QMI service major version and is provided here
   *              from the request version.
   * @param uint32 requestId generated by the user for the request.
   * @param uint32 Unique ID of the Client who made corresponding request.
   */
  LOWIResponse (eSupportedServiceVersion version, uint32 requestId, uint32 clientId);

  /**
   * Destructor
   */
  virtual ~LOWIResponse () = 0;

  /**
   * Request id generated and provided in request by the client.
   * Echoed back in the response.
   * @return Corresponding Request id
   */
  uint32 getRequestId ();

  /**
   * Returns the response type
   * @return eResponseType Type of Response
   */
  virtual eResponseType getResponseType () = 0;

  /** Returns the supported version number which depends on the request
   * version number
   */
  virtual eSupportedServiceVersion getSupportedVersion ();

  /**
   * Returns the client ID
   */
  virtual uint32 getClientId ();
};

/**
 * This class defines the Capabilities of the WifiDriver
 */
class LOWICapabilities
{
public:
  QmiLowiCapabilitiesResponseInd_v01 capabilities;
  LOWICapabilities ()
  {
    memset (&capabilities, 0, sizeof(QmiLowiCapabilitiesResponseInd_v01));
  }
};


/**
 * Response to the Capability Request
 */
class LOWICapabilityResponse : public LOWIResponse
{
private:
#if 0
  LOWICapabilities mCapabilities;
#endif
  bool             mStatus;

public:
  QmiLowiCapabilitiesResponseInd_v01 capabilities;

  /**
   * Constructor
   * @param uint32 requestId generated by the user for the request.
   * @param uint32 Unique ID of the Client who made corresponding request.
   * @param QmiLowiCapabilitiesResponseInd_v01* Capabilities
   * @param bool true for success, false to indicate failure
   */
  LOWICapabilityResponse (uint32 requestId, uint32 clientId,
      QmiLowiCapabilitiesResponseInd_v01* cap, bool status );

  /** Destructor*/
  virtual ~LOWICapabilityResponse ();

  /**
   * Returns the response type
   * @return eResponseType Type of Response
   */
  virtual eResponseType getResponseType ();

#if 0
  /**
   * Return the capabilities
   * @return LOWICapabilities
   */
  LOWICapabilities getCapabilities ();
#endif

  /**
   * Returns the status of the Request
   * @return bool true for success, false otherwise
   */
  bool getStatus ();

};

#if 0
/**
 * Response to the Cache reset Request
 */
class LOWICacheResetResponse : public LOWIResponse
{
private:
  bool mCacheResetStatus;
public:
  /**
   * Constructor
   * @param uint32 requestId generated by the client for request
   * @param bool true for success, false to indicate failure
   */
  LOWICacheResetResponse (uint32 requestId, bool status);
  /** Destructor*/
  virtual ~LOWICacheResetResponse ();

  /**
   * Returns the response type
   * @return eResponseType Type of Response
   */
  virtual eResponseType getResponseType ();

  /**
   * Returns the status of the Request
   * @return bool true for success, false otherwise
   */
  bool getStatus ();
};
#endif

/**
 * Response to the Discovery Scan Request
 */
class LOWIDiscoveryScanResponse : public LOWIResponse
{
private:

public:
  vector <QmiLowiDiscoveryResponseInd_v01*> discovery_resp_v01;

  /** Response type*/
  enum eScanTypeResponse
  {
    WLAN_SCAN_TYPE_UNKNOWN = 0,
    WLAN_SCAN_TYPE_PASSIVE,
    WLAN_SCAN_TYPE_ACTIVE
  };


  /** This may be different than the requested ScanType,
   * since user may request active scan, but if there’s an ongoing
   * passive scan results, LOWI may give back those results.*/
  eScanTypeResponse  getScanTypeResponse ();

  /** Status of the scan */
  eScanStatus  getScanStatus ();
#if 0
  /**
   * Returns the Array containing received ScanMeasurements
   * MAX Array size is MAX_APS_ALLOWED.
   * @param[out] LOWIScanMeasurement* Pointer to an array to hold the scan measuments
   * @param[in] uint32 Indicates how big of a array it is or how many measurements are needed.
   *                    This can not be less than the size of the array. If it is more than
   *                    MAX_APS_ALLOWED, then only MAX_APS_ALLOWED measurements are returned.
   * @return uint32 Number of Nodes / APs found / added to the array
   */
  uint32 getScanMeasurements (LOWIScanMeasurement* arr, uint32 measurements_needed);

  /**
   * Returns the Array containing scanned frequencies
   * MAX Array size is MAX_FREQS_ALLOWED
   * @param[out] LOWIScanMeasurement* Pointer to an array to hold the scanned frequencies
   * @param[in] uint32 Indicates how big of a array it is or how many frequencies are needed.
   *                    This can not be less than the size of the array. If it is more than
   *                    MAX_FREQS_ALLOWED, then only MAX_FREQS_ALLOWED frequencies are returned.
   * @return uint32 Number of frequencies scanned, added to the array
   */
  uint32 getScannedFrequencies (uint32* arr, uint32 freq_needed);
#endif
  /**
   * Constructor
   * @param uint32 Corresponding Request Id generated by the client for request
   */
  LOWIDiscoveryScanResponse (uint32 requestId);

  /**
   * Constructor
   * @param uint32 requestId generated by the user for the request.
   * @param uint32 Unique ID of the Client who made corresponding request.
   * @param vector<QmiLowiDiscoveryResponseInd_v01*> response
   */
  LOWIDiscoveryScanResponse (uint32 requestId, uint32 clientId,
      vector <QmiLowiDiscoveryResponseInd_v01*> resp);

  /** Destructor*/
  virtual ~LOWIDiscoveryScanResponse ();

  /**
   * Returns the response type
   * @return eResponseType type of Response
   */
  virtual eResponseType getResponseType ();
};


/**
 * Response to the Ranging scan Request
 */
class LOWIRangingScanResponse: public LOWIResponse
{
public:
  /** Status of the scan */
  eScanStatus             scanStatus;
  #if 0
  /** Dynamic array containing received ScanMeasurement*/
  vector <LOWIScanMeasurement*> scanMeasurements;

  /**
   * Constructor
   * @param uint32 Request Id generated by the client for Request
   * @param uint32 Client ID
   * @param vector <LOWIScanMeasurement*> Vector of measurements
   */
  LOWIRangingScanResponse (uint32 requestId, uint32 clientId,
                                          vector <LOWIScanMeasurement*> resp);
  #endif
    vector<QmiLowiRangingResponseInd_v01*> mResponse;

  /**
  * Constructor
  * @param uint32 requestId generated by the user for the request.
  * @param uint32 Unique ID of the Client who made corresponding request.
  * @param vector<QmiLowiRangingResponseInd_v01*> response
  */
  LOWIRangingScanResponse (uint32 requestId,
        uint32 clientId, vector<QmiLowiRangingResponseInd_v01*> resp);
  /** Destructor*/
  virtual ~LOWIRangingScanResponse ();

  /**
   * Returns the response type
   * @return eResponseType type of Response
   */
  virtual eResponseType getResponseType ();
};


class LOWIAsyncDiscoveryScanResultResponse :
  public LOWIDiscoveryScanResponse
{
public:
    /**
     * Constructor
     * @param uint32 requestId generated by the user for the request.
     * @param uint32 Unique ID of the Client who made corresponding request.
     * @param vector<QmiLowiDiscoveryResponseInd_v01*> response
     */
    LOWIAsyncDiscoveryScanResultResponse (uint32 requestId,
        uint32 clientId, vector<QmiLowiDiscoveryResponseInd_v01*> resp);

    /** Destructor*/
    virtual ~LOWIAsyncDiscoveryScanResultResponse ();

    /**
     * Returns the response type
     * @return eResponseType type of Response
     */
    virtual eResponseType getResponseType ();
};

class LOWIWlanStateResponse : public LOWIResponse
{
public:
  QmiLowiWlanInterfaceEventsResponseInd_v01 mResp;
#define WLAN_ON_OFF_EVENT WLAN_ON_OFF_EVENT_V01
#define WLAN_CONNECTION_EVENT WLAN_CONNECTION_EVENT_V01
#define WLAN_HANDOFF_EVENT WLAN_HANDOFF_EVENT_V01

  /**
   * Constructor
   * @param uint32 requestId generated by the user for the request.
   * @param uint32 Unique ID of the Client who made corresponding request.
   * @param QmiLowiWlanInterfaceEventsResponseInd_v01* Pointer to the response
   */
    LOWIWlanStateResponse (
        uint32 requestId, uint32 clientId,
        QmiLowiWlanInterfaceEventsResponseInd_v01* state);

    /** Destructor*/
    virtual ~LOWIWlanStateResponse ();

    /**
     * Returns the response type
     * @return eResponseType type of Response
     */
    virtual eResponseType getResponseType ();

    /**
     * Returns the Event/s that caused the response to be generated.
     * It could be a number of events including WLAN ON, Connection or handoff
     */
    uint64 getEvents ();

    /**
     * Returns the WLAN state ON / OFF
     * @return bool true for ON, false for OFF
     */
    bool getWlanState ();

    /**
     * Returns the WLAN connection status CONNECTED / DISCONNECTED
     * @return bool true for Connected, false for DISCONNECTED
     */
    bool getWlanConnectionStatus ();
#if 0
    /**
     * Returns the BSSID of the connected Node.
     * Note: Only valid if the Event is for connected / handoff
     * @param[out] LOWIMacAddress& BSSID of the connected Node
     */
    void getConnectedNodeBssid (LOWIMacAddress& mac);

    /**
     * Returns the freq of the connected Node.
     * Note: Only valid if the Event is for connected / handoff
     * @return uint32 Frequency of the connected Node
     */
    uint32 getConnectedNodeFreq ();


    /**
     * Returns the SSID of the connected Node.
     * Note: Only valid if the Event is for connected / handoff
     * @param[out] LOWISsid SSID of the connected Node
     */
    void getConnectedNodeSsid (LOWISsid& ssid);
#endif

};

class LOWIBatchingSubscriptionResponse :
  public LOWIResponse
{
public:
    QmiLowiBatchingSubscriptionInd_v01 mResponse;

    /**
     * Constructor
     * @param uint32 requestId generated by the user for the request.
     * @param uint32 Unique ID of the Client who made corresponding request.
     * @param QmiLowiBatchingSubscriptionInd_v01* response
     */
    LOWIBatchingSubscriptionResponse (uint32 requestId,
        uint32 clientId, QmiLowiBatchingSubscriptionInd_v01* resp);

    /** Destructor*/
    virtual ~LOWIBatchingSubscriptionResponse ();

    /**
     * Returns the response type
     * @return eResponseType type of Response
     */
    virtual eResponseType getResponseType ();
};

class LOWIBatchingResultsResponse :
    public LOWIResponse
{
public:
      vector<QmiLowiGetBatchingResultsInd_v01*> mResponse;

    /**
     * Constructor
     * @param uint32 requestId generated by the user for the request.
     * @param uint32 Unique ID of the Client who made corresponding request.
     * @param vector<QmiLowiGetBatchingResultsInd_v01*> response
     */
      LOWIBatchingResultsResponse (uint32 requestId,
        uint32 clientId, vector<QmiLowiGetBatchingResultsInd_v01*> resp);

    /** Destructor*/
    virtual ~LOWIBatchingResultsResponse ();

    /**
     * Returns the response type
     * @return eResponseType type of Response
     */
    virtual eResponseType getResponseType ();
};

class LOWIBGScanSubscriptionResponse :
      public LOWIBatchingSubscriptionResponse
{
public:

    /**
     * Constructor
     * @param uint32 requestId generated by the user for the request.
     * @param uint32 Unique ID of the Client who made corresponding request.
     * @param QmiLowiBatchingSubscriptionInd_v01* response
     */
        LOWIBGScanSubscriptionResponse (uint32 requestId,
        uint32 clientId, QmiLowiBatchingSubscriptionInd_v01* resp);

    /** Destructor*/
    virtual ~LOWIBGScanSubscriptionResponse ();

    /**
     * Returns the response type
     * @return eResponseType type of Response
     */
    virtual eResponseType getResponseType ();
};

class LOWIBGScanResultsResponse :
    public LOWIResponse
{
public:
      vector<QmiLowiGetBGScanBatchingResultsInd_v01*> mResponse;

    /**
     * Constructor
     * @param uint32 requestId generated by the user for the request.
     * @param uint32 Unique ID of the Client who made corresponding request.
     * @param vector<QmiLowiGetBGScanBatchingResultsInd_v01*> response
     */
      LOWIBGScanResultsResponse (uint32 requestId,
        uint32 clientId, vector<QmiLowiGetBGScanBatchingResultsInd_v01*> resp);

    /** Destructor*/
    virtual ~LOWIBGScanResultsResponse ();

    /**
     * Returns the response type
     * @return eResponseType type of Response
     */
    virtual eResponseType getResponseType ();
};


/**
 * Response to the Extended Ranging Results Request
 */
class LOWIExtRangingResultsResponse: public LOWIResponse
{
public:
  /** Status of the scan */
  eScanStatus             scanStatus;
  vector<QmiLowiExtRangingResultsResponseInd_v01*> mResponse;

  /**
  * Constructor
  * @param uint32 requestId generated by the user for the request.
  * @param uint32 Unique ID of the Client who made corresponding request.
  * @param vector<QmiLowiRangingResponseInd_v01*> response
  */
  LOWIExtRangingResultsResponse (uint32 requestId,
    uint32 clientId, vector<QmiLowiExtRangingResultsResponseInd_v01*> resp)
    : LOWIResponse (VER_01, requestId, clientId)
  {
	mResponse = resp;
  }

  /** Destructor*/
  virtual ~LOWIExtRangingResultsResponse ()
  {
    for (unsigned int ii = 0; ii < mResponse.getNumOfElements(); ++ii)
    {
      delete mResponse[ii];
    }
  }

  /**
   * Returns the response type
   * @return eResponseType type of Response
   */
  virtual eResponseType getResponseType ()
  {
	return EXT_RANGING_RESULTS_REQ;
  }
};


} // namespace qc_loc_fw

#endif //#ifndef __LOWI_RESPONSE_H__
