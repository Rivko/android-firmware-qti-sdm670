;============================================================================
;
;   Heap Walker v2.2
;
;       Parses a given memheap and gets the statistics
;       Doesn't pinpoint who is causing the problem.
;       Provides the following in the summary (further parsed by 
;       the heapparser script:
;
;   Procedure:
;       1) Load the ELF file into T32 Simulator
;       2) Load the Jtag log or ram dumps (if working with Jtag log)
;       3) In the T32 Cmd Line : "do memheap2_heapWalker <Heap Variable> <Output Dir>"
;       4) Follow the output shown in "AREA ST" to fetch the results.
;
;
; Copyright (c) 2006-2015 by Qualcomm Technologies, Incorporated.  All Rights Reserved.
;============================================================================

;============================================================================
;
;                        EDIT HISTORY FOR MODULE
;
; $Header: //components/rel/dspcore.adsp/4.0/scripts/crashman/memheap2_heapWalker_Latest.cmm#3 $ 
; $DateTime: 2017/07/26 05:14:42 $ 
; $Author: pwbldsvc $
;
;  when        who     what, where, why
; ---------    ---     --------------------------------------------------------
;05/16/14       rks    heap walker script v2.0
;01/21/14       rks    updated script to continue heap walk even after corruption is detected
;                      Also to take alarming false positive care in if ASSERTion 
;                      occured in between of a heap operation inside mem_free()
; 02/05/13      ps     Updated scripts for debug information in headers
; 11/16/12      ps     Unified scripts and added retreival of free block caller
; 02/05/07      mk     Added Memory Overflow Detection
; 10/01/07      mk     Created this script
;============================================================================

LOCAL &OpT32File
LOCAL &OpPlFile
LOCAL &HeapParserScript
;LOCAL &BlockHeaderSize
LOCAL &DebugModeCheck
LOCAL &DebugMethod
LOCAL &debug_info
LOCAL &debug_info_symbol
LOCAL &MemDebugSize
LOCAL &debug_index
LOCAL &stats_index
&BINsCorruption=0
&DoIntCheckReturn=0
&NextValidBlock=0
&calchashNext=0
&freeFlag_resolve_corruption=0
&freeFlagBlock_r_c=0
&lastflag=0
&count=0
&lastBlockCorruption=0
&tls_stats_index_count=0
&memheap_tls_to_tname=0
&utcb_to_tcbname=0

  
&incomBlockInBinNo=0xABCD; initilized with some garbage number since BIN 0 is also a valid BIN
&incomBlockBelongsToSec=0
&incomBlockFound=0

LOCAL &BuildInfo
&qc_image_version=""
&qc_build_id=""

ENTRY &HeapVar &OpDir &BlockHeaderSize

ON ERROR JUMPTO memheap_end


Area.Create ST 200. 1000.       ;create an AREA window              
WINPOS 50% 0. 50% 103% 0. 0. ST
Area.Select ST                  ;select the AREA window as PRACTICE 
                                ;input/output window                
Area ST                         ;display the AREA window            
&HeapParserScript=OS.PWD();
&HeapParserScript="&HeapParserScript"+"\memheap2_heapwalkparser_Latest.pl"
;Set the version of the script:
; 00.00.01 -- First Walker Script for Mem Heap With CRC enabled
&CMMVERSION="00.00.01"

print "====================Heap Walker v2.2==========================="
print ".......  go/HeapDebug for more heap debugging help\tips........"
print "---------------------------------------------------------------"

if ("&HeapVar"=="")
(
        print "Enter the heap variable to be parsed:"
        enter &HeapVar

)

&varLen=STRing.LENgth("&HeapVar")
&rm_last=0
&pos=0
&prePos=0
&i=0
while (&pos!=-1)
(
   
   &pos=STRING.SCAN("&HeapVar","\",(&pos+1))
   if (&pos!=-1)
   (
     &rm_last=&pos
   )
   &i=&i+1
   if (&i==2)
   (
     &prePos=&pos
   )
   
)


&appendStr=STRing.CUT("&HeapVar",-(&varLen-&rm_last-1))
&appendMemDebuStr=STRing.CUT("&HeapVar",-(&varLen-&prePos-1))

&varLen=STRing.LENgth("&appendStr")

&heapname=STRing.CUT("&HeapVar",+&varLen)

&memdebug_db="&appendMemDebuStr"+"amssheap\memdebug_amss_heap"
&pos=STRING.SCAN("&HeapVar","Global",0)
if (&pos!=-1)
(
  &memheap_tls_to_tname="&appendStr"+"memheap_tls_to_tname"
  &utcb_to_tcbname="&appendStr"+"memheap_utcb_to_tcbname"
  &tls_stats_index_count="&appendStr"+"tls_stats_index_count"
)
else
(
  &memheap_tls_to_tname="&appendMemDebuStr"+"Global\memheap_tls_to_tname"
  &utcb_to_tcbname="&appendMemDebuStr"+"Global\memheap_utcb_to_tcbname"
  &tls_stats_index_count="&appendMemDebuStr"+"Global\tls_stats_index_count"
)
&MemHeapTypeSize=0
if ("&BlockHeaderSize"=="")
(
    &BlockHeaderSize=16
)

&DebugModeCheck=0
&DebugMethod=0
&isHeapStats=1
&heapStatistics=0

 &heapusedhash=V.VALUE((mem_heap_type *) &HeapVar.magic_num_used)
 &heapfreehash=V.VALUE((mem_heap_type *) &HeapVar.magic_num_free)
 
if (&BlockHeaderSize>8)
(
   &DebugModeCheck=1
   print "Debug mode is enabled on this build"
)

&heapStructSize=v.value(sizeof(&HeapVar))
if (&heapStructSize==0x3DC)
( 
 &heapStatistics=v.value(&HeapVar.heapStatistics)
)

if (&heapStatistics==0)
(
   &isHeapStats=0
   print "!!!!"
   print "Heap Statistics not found for heap."
   print "!!!!"
)

if (&DebugModeCheck==1)
(
   if (!Y.EXIST("memdebug_amss_heap"))
   (
      print "Using inline debug information"
      &DebugMethod=1
   )
   else
   (
      print "Using DB array information"
      &MemDbgArraySize=Var.END(&HeapVar->debug_array->db)-Var.ADDRESS(&HeapVar->debug_array->db[0])+1
      &MemDebugSize=&MemDbgArraySize/v.value(sizeof(memdebug_db_s_type))
      &DebugMethod=2
      print "MemDebugSize = &MemDebugSize"      
   )
)
 
 &mutexTaken=0
 &falsePositiveBlock=0
 &crit_sect=V.VALUE(&HeapVar.memheap_crit_sect)
 &raw=(V.VALUE(((osal_crit_sect_t*)&crit_sect)->raw))
 if (0xFE!=&raw)
 (

   &mutexTaken=1
   print "*******Heap Mutex is taken :some memory block is in process, " 
   print "       for the block it may not have the header data completly updated , so should consider it while doing heap analysis*********"
   print "  "
 )

&incoming_Block=V.VALUE((mem_heap_type *)&HeapVar.incomingBlock)

if ("&OpDir"=="")
(
        print "Please enter the directory where the results should be stored"
        dialog.dir *.*
        ENTRY &OpDir
)
if ("&OpDir"=="")
(
        print "Output Dir not chosen.. Bailing Out...."
        enddo
)

if ("&MemDebugSize"=="")
(
        &MemDebugSize=8000
)
if (!os.file(&HeapParserScript))
(
      dialog.file *.pl
      ENTRY &HeapParserScript
)
if ("&HeapParserScript"!="")
(
  if (!os.file(&HeapParserScript))
  (
       print "Parser Script not chosen.. Bailing Out...."
       enddo
  )
)
else
(
  print "Parser Script not chosen.. Bailing Out...."
  enddo
)
if (Y.EXIST(QC_IMAGE_VERSION_STRING_AUTO_UPDATED))
(
   &qc_image_version=V.STRING(QC_IMAGE_VERSION_STRING_AUTO_UPDATED)
)
if (Y.EXIST(IMAGE_VARIANT_STRING_AUTO_UPDATED))
(
   &qc_build_id=V.STRING(IMAGE_VARIANT_STRING_AUTO_UPDATED)
)
if ("&qc_image_version"!="")
(
    
    WHILE STRING.FIND("&qc_image_version","=")
        &qc_image_version=STRING.CUT("&qc_image_version",1)
    print "Image version = &qc_image_version"
    &BuildInfo="&qc_image_version"
)

if ("&qc_build_id"!="")
(
    WHILE STRING.FIND("&qc_build_id","=")
        &qc_build_id=STRING.CUT("&qc_build_id",1)
    print "Build Id = &qc_build_id"
    &BuildInfo="&BuildInfo"+"_&qc_build_id"
)
&OpT32File="&OpDir\"+"&BuildInfo"+"_"+"&heapname"+"_MemBlkList.csv" ;
&OpT32FileMemDb="&OpDir\"+"&BuildInfo"+"_"+"&heapname"+"_memdebug_db_MemBlkList.csv" ;
&OpT32FileStatsDb="&OpDir\"+"&BuildInfo"+"_"+"&heapname"+"_threadstats.csv" ;
&OpPlFile="&OpDir\"+"&BuildInfo"+"_"+"&heapname"+"_MemCost.csv"

if (&DebugMethod==2)
( 
    gosub walkDebugDB &HeapVar &OpDir &MemDebugSize
)
&legacyCheck=V.VALUE(&HeapVar.legacy_check)
if (&legacyCheck==0x2)
(
  print "   "
  print "---Start: verifying the free memory block's BINs in the heap--- "
  print "   "
  gosub walkBINs &HeapVar
  print "---End:free BINs verification -----------------------------------"
  print "   "
)

if (&isHeapStats==1)
(
    &statsCount=v.value(&tls_stats_index_count)
    gosub walkStatsDB &HeapVar &OpDir &statsCount
)
print "1. Walking through the heap"
gosub walkHeap &HeapVar &OpDir
print "2. Running the Parser"
gosub ProcHeap &OpT32File &OpT32FileMemDb &OpPlFile &BlockHeaderSize
print "3. Exit"
enddo


	   
walkBINs:
ENTRY &HeapVar
&i=0
&totalBINsCount=0x20 ;0x20 is the max BINs count
  while (&i<&totalBINsCount) 
  (
     &j=0
     &nextBlock=0
     &nextBlock_backUp=0
     &corruptedBlock=0
     &infiniteLoop=0
     &curr_bin_firstBlock=V.VALUE((mem_heap_type *) &HeapVar.BIN[&i].firstNode)
     &total_Nodes=V.VALUE((mem_heap_type *) &HeapVar.BIN[&i].totalNodes)
     if (&curr_bin_firstBlock!=0x0)
     (
         &nextBlock=&curr_bin_firstBlock
         while (&nextBlock!=0x0)
         (
            &nextBlock_backUp=&nextBlock
            &blkhashNext=V.VALUE(*((uint16*) &nextBlock))
            &calchash0=V.VALUE(*((uint16*) &nextBlock))
            &calchash2=V.VALUE(*((uint16*) &nextBlock+1))
            &calchash4=V.VALUE(*((uint16*) &nextBlock+2))
            &calchash6=V.VALUE(*((uint16*) &nextBlock+3))
            &calchash8=V.VALUE(*((uint16*) &nextBlock+4))
            &calchash10=V.VALUE(*((uint16*) &nextBlock+5))
            &calchashNext=&calchash2^&calchash4^&calchash6^&calchash8^&calchash10^&heapfreehash
            if (&blkhashNext==&calchashNext)
            (
                &j=&j+1
                &nextBlock=V.VALUE(*((uint32*) &nextBlock+2))
                if (&total_Nodes<&j)
                (
                   &nextBlock=0
                   &infiniteLoop=1
                   print "<<<<<Infinite loop detected at BIN = &i >>>>>>"
                   print "  "
                )
            )
            else
            (
                &corruptedBlock=&nextBlock
                &nextBlock=0
            )
            if (&incoming_Block==&nextBlock_backUp)
            (
                 &incomBlockInBinNo=&i
            )
         )
     )

     if ((&j!=&total_Nodes)&&(&infiniteLoop==0))
     (
        print " -----------------------------------------------------------------------------------------------------------------------------------------------------"
        print "Corruption detected in free blocks BINs at bin no. =&i  "
        print "Total *valid* Free Blocks expected =  &total_Nodes , and found = &j *valid* blocks"
        print "Issue detected: the free block = &corruptedBlock in the bin number =&i is corrupted so stopped further traversing on this BIN's free block's list"
        print " -----------------------------------------------------------------------------------------------------------------------------------------------------"
        print "   "
        &BINsCorruption=1
     )
     &i=&i+1
  )
  ; check if there any corruption in binToUSeForMalloc in freeBlokcStruct 
  ;since sometimes memory allcoation failure occures due to this as well
  &i=0
  while (&i<&totalBINsCount) ;0x20 is the max BINs count
  (
    &binToUSe=V.VALUE((mem_heap_type *) &HeapVar.BIN[&i].binToUSeForMalloc)
    &nodePtr=V.VALUE((mem_heap_type *) &HeapVar.BIN[&binToUSe].firstNode)
    if (((&nodePtr==0)&&(&binToUSe!=(&totalBINsCount-1)))||(&binToUSe<&i))
    (
       print " -----------------------------------------------------------------------------------------------------------------------------------------------------"
       print "Corruption detected in free blocks BINs at bin no. =&i  for binToUSeForMalloc"
       print "Side effect(issue) can be caused due to this is: FALSE heap exhaustion(i.e. unable to allcoate requested memory even though enough of the memory availble in the heap) "
       print " -----------------------------------------------------------------------------------------------------------------------------------------------------"
       print "   "
    )
    &i=&i+1
  )
return ;End of walkBINs

DoIntCheck:
ENTRY &next_heap_block

    &blkhashNext=V.VALUE(*((uint16*) &next_heap_block))
    &flagbytes=V.VALUE(*((uint8*) &next_heap_block + 3))
    &freeflag_t=(&flagbytes&0x40)>>6

    if (&freeflag_t==0)
    (
      &calchash0=V.VALUE(*((uint16*) &next_heap_block))
      &calchash2=V.VALUE(*((uint16*) &next_heap_block+1))
      &calchash4=V.VALUE(*((uint16*) &next_heap_block+2))
      &calchash6=V.VALUE(*((uint16*) &next_heap_block+3))
      &calchashNext=&calchash2^&calchash4^&calchash6^&heapusedhash           
    )
    if (&freeflag_t==1)
    (
      &calchash0=V.VALUE(*((uint16*) &next_heap_block))
      &calchash2=V.VALUE(*((uint16*) &next_heap_block+1))
      &calchash4=V.VALUE(*((uint16*) &next_heap_block+2))
      &calchash6=V.VALUE(*((uint16*) &next_heap_block+3))
      &calchash8=V.VALUE(*((uint16*) &next_heap_block+4))
      &calchash10=V.VALUE(*((uint16*) &next_heap_block+5))
      &calchashNext=&calchash2^&calchash4^&calchash6^&calchash8^&calchash10^&heapfreehash
    )
    if (&calchashNext!=&blkhashNext)
    (
      &DoIntCheckReturn=1
    )
    else
    (
      &DoIntCheckReturn=0
    )
return ;end DoIntCheck


FindNextValidBlock:
ENTRY &curr_heap_mem &curr_heap_end
    print "Trying to find out next valid block .....";
    &exitfromLoop=0
    while ((&curr_heap_mem<&curr_heap_end)&&(&exitfromLoop==0))
    (
        &curr_heap_mem=&curr_heap_mem+0x10
        &NextValidBlock=0
        &size=V.VALUE(*((uint32*) &curr_heap_mem + 1))

        &maxFrdOffset=&curr_heap_end-&curr_heap_mem
        &maxFrdOffset=&maxFrdOffset+1
        if ((&size!=0)&&(&size<&maxFrdOffset))
        (
          gosub DoIntCheck &curr_heap_mem
          if (&DoIntCheckReturn==0)
          (
              print "Next valid memory block =: &curr_heap_mem";
              print " "
              &exitfromLoop=1
              &NextValidBlock=&curr_heap_mem
           )
       )

       if (&curr_heap_mem>=&curr_heap_end)
       (
          &lastflag=0x01
          &lastBlockCorruption=1
          print " ---It was the last memory block of this heap Section---"
       )
    )
    print " -----------------------------------------------------------"
return ;end FindNextValidBlock

walkHeap:
ENTRY &HeapVar &OpDir

&tcb_ptr_symbol=""
&thread_id=0x0
&found=0
&tls_id=0x0

; Initialize the heap buffer pointer
 &curr_heap_mem=V.VALUE((mem_heap_type *) &HeapVar.first_block)

 &HeapMemBuffer=Y.NAME(D:&curr_heap_mem)

 &legacy=0
 &legacyCheck=V.VALUE(&HeapVar.legacy_check)
 if (&legacyCheck!=2)
 (
    &legacy=1
 )
 
 OPEN #1 &OpT32File /Create 

&maxHeapUsed=V.VALUE((mem_heap_type *) &HeapVar.max_used)
&currentHeapUsage=V.VALUE((mem_heap_type *) &HeapVar.used_bytes)
; Important : Don't change this header! Used by Parser as is.
 WRITE #1 "Blocks List Report" 
 WRITE #1 "------------------"
 WRITE #1 "Version                          : &CMMVERSION"  
 WRITE #1 "Heap State Variable              : &HeapVar"
 WRITE #1 "Heap Buffer                      : &HeapMemBuffer"
 WRITE #1 "Maximum heap usage(Watermark)    : &maxHeapUsed Bytes"
 WRITE #1 "Current heap usage               : &currentHeapUsage Bytes"
 WRITE #1 "  "
if (&DebugModeCheck==1)
(
    WRITE #1 "Block No ,Address,CallerPtr,CallerPtr_Symbol,TaskName, Thread Index, Allocated Bytes,Extra Bytes,Section_index,Start Flag,Free Flag,Last Flag"
)
else
(
    WRITE #1 "Block No,Address,Allocated Bytes,Extra Bytes,Section_index,Start Flag,Free Flag,Last flag"
)

 &count=1;
 &writestring=""
if (&DebugModeCheck==1)
(
   &debug_info=0x0
   &debug_info_symbol=""
)
&concatenatedWithPrevBlock=0
&hash=0x0
&pre_block_free_flag=0
&pre_mem_block=0
&pre_block_section=0
&corruptedBlock=0
 &size=0
 &number_of_sections=0
 &total_number_of_sections=V.VALUE((mem_heap_type *) &HeapVar.number_of_sections)
 if (&total_number_of_sections==0)
 (
    &total_number_of_sections=1
 ) 
 while (&number_of_sections!=&total_number_of_sections)
 (
     &heapSectionSize=V.VALUE((mem_heap_type *) &HeapVar.sections[&number_of_sections].size)
     &heapSectionStartAddr=V.VALUE((mem_heap_type *) &HeapVar.sections[&number_of_sections].start_addr)
     &curr_heap_end= &heapSectionSize+&heapSectionStartAddr
     &size=0
     if ((&incoming_Block<&curr_heap_end)&&(&heapSectionStartAddr<=&incoming_Block))
     (
        &incomBlockBelongsToSec=&number_of_sections
        &incomBlockFound=1
     )
     while ((&lastflag!=0x01)&&(&curr_heap_mem<&curr_heap_end))
     (
         &thread_id=0
         &tcb_ptr_symbol=0
         &&debug_info=0
         &debug_info_symbol=0
         &handled=0
         &flagbytes=V.VALUE(*((uint8*) &curr_heap_mem + 3))
         &freeflag=(&flagbytes&0x40)>>6

         &blkhash=V.VALUE(*((uint16*) &curr_heap_mem))
         gosub DoIntCheck &curr_heap_mem
         if (&DoIntCheckReturn!=0)
         (
             &calchashSecond=0
             if ((&mutexTaken==1)&&(&freeflag==1))
             (
                 &falsePositiveBlock=1
                 &calchash0=V.VALUE(*((uint16*) &curr_heap_mem))
                 &calchash2=V.VALUE(*((uint16*) &curr_heap_mem+1))
                 &calchash4=V.VALUE(*((uint16*) &curr_heap_mem+2))
                 &calchash6=V.VALUE(*((uint16*) &curr_heap_mem+3))
                 &calchashSecond=&calchash2^&calchash4^&calchash6^&heapusedhash^0x4000 ; XOR with 0x4000 since freeFlag is set
             )

             if ((&blkhash==&calchashSecond)&&(&blkhash!=0))
             (
                print "===================================================================";
                print "heap block's free_flag setting to 0 passed the integrity test on the Block Address: &curr_heap_mem ,"
                print " mostly this is the memory block pointer passed in mem_free() = &curr_heap_mem+0x10"
                print "===================================================================";
                &handled=1
                &freeFlag_resolve_corruption=1
                &freeFlagBlock_r_c=&curr_heap_mem
                &freeflag=0 ; setting free_flag to 0 for printing its inforamtion in the output file

             )
             if ((&mutexTaken==1)&&(&blkhash!=&calchashSecond)&&(&blkhash!=0)&&(&freeflag==1)&&(&handled==0))
             (
                  &sizeN=V.VALUE(*((uint32*) &curr_heap_mem + 1))
                  &next_heap_block=&curr_heap_mem+&sizeN
                  gosub DoIntCheck &next_heap_block
                  &maxSize=&curr_heap_end-&curr_heap_mem
                  if ((&DoIntCheckReturn!=0)&&(&sizeN<=&maxSize))
                  (
                     while ((&curr_heap_mem<&next_heap_block)&&(&found==0))
                     (
                       &next_heap_block=&next_heap_block-0x10
                       &value0=V.VALUE(*((uint32*) &next_heap_block))
                       &value1=V.VALUE(*((uint32*) &next_heap_block +1))
                       &value3=V.VALUE(*((uint32*) &next_heap_block +3))
                       &value3=&value3>>16 ; MSB 4 bytes has to be 0 for this since its storing the stats_index that has max value as 0x3E7
                       if ((&value3==0x0)&&(&value0==0x0)&&(&value1==0x0)&&((&incoming_Block-0x10)==&next_heap_block))
                       (
                            &found=1
                            &corruptedBlock=&curr_heap_mem+&sizeN
                            print " "
                            print "<<<IncomingBlock got *concatenated*>>>"
                            print " "
                            print "The ptr passed in mem_free() got concatenated with the prev. free block = &curr_heap_mem  !!";
                            print "Memory block got corrupted is &corruptedBlock ";
                            &next_heap_block=&next_heap_block+0x10
                            print "the ptr passed in mem_free() = &next_heap_block and this is the block that caused corruption"
                            &debug_info=V.VALUE(*((uint32*) (&incoming_Block-0x10) + 2))
                            &debug_info_symbol= Y.NAME(D:&debug_info)
                            &stats_index=V.VALUE(*((uint32*) (&incoming_Block-0x10) + 3))
                            if (&isHeapStats==1)
                            (
                               &tcb_ptr_symbol= V.STRING(&memheap_tls_to_tname[&stats_index])
                               &thread_id=&stats_index
                            )
                            &thread_id=&stats_index
                            print " This block(&next_heap_block) was allocated from function(i.e. Owner of it) = &debug_info_symbol , task = &tcb_ptr_symbol ,thread_id = &thread_id"
                            print " "
                            &next_heap_block=&next_heap_block-0x10
                            print "<<<End of info for this block>>>"
                            print " "
                            &handled=1
                            &concatenatedWithPrevBlock=1
                        )
                     )
                  )
                  else if (&sizeN<=&maxSize)
                  (
                     while ((&curr_heap_mem<&next_heap_block)&&(&found==0))
                     (
                       &next_heap_block=&next_heap_block-0x10
                       &value0=V.VALUE(*((uint32*) &next_heap_block))
                       &value1=V.VALUE(*((uint32*) &next_heap_block +1))
                       &value3=V.VALUE(*((uint32*) &next_heap_block +3))
                       &value3=&value3>>16 ; MSB 4 bytes has to be 0 for this since its storing the stats_index that has max value as 0x3E7
                       if ((&value3==0x0)&&(&value0==0x0)&&(&value1==0x0)&&((&incoming_Block-0x10)==&next_heap_block))
                       (
                            &found=1
                            &corruptedBlock=&curr_heap_mem+&sizeN
                            print " "
                            print "<<<IncomingBlock got *concatenated*>>>"
                            &next_heap_block=&next_heap_block+0x10
                            print "The ptr passed &next_heap_block in mem_free() got concatenated with the prev. free block = &curr_heap_mem  !!";
                            &next_heap_block=&next_heap_block-0x10
                            print "<<<End of info for this block>>>"
                            print " "
                            &handled=1
                        )
                     )
                  )
                  ;check if the block got concatenated with the nextBlock
                  if (&handled==0)
                  (
                     &sizeN=V.VALUE(*((uint32*) &curr_heap_mem + 1))
                     &exit=0
                     while ((&sizeN<=&maxSize)&&(&sizeN>0)&&(&exit==0))
                     (
                         &calchashSecond=0
                         (
                             &falsePositiveBlock=1
                             &calchash0=V.VALUE(*((uint16*) &curr_heap_mem))
                             &calchash2=V.VALUE(*((uint16*) &curr_heap_mem+1))
                             &calchash4=(0xFFFF0000&(&sizeN))
                             &calchash6=0x0000FFFF&(&sizeN)
                             &calchashSecond=&calchash2^&calchash4^&calchash6^&heapusedhash^0x4000 ; XOR with 0x4000 since freeFlag is set
                         )

                         if ((&blkhash==&calchashSecond)&&(&blkhash!=0))
                         (
                            &nextBlock=&curr_heap_mem+&sizeN
                            print "============================================================================================================";
                            print " The ptr passed  &curr_heap_mem+0x10 in mem_free()  got concatenated  with the next free block = &nextBlock "
                            print "=============================================================================================================";
                            &handled=1
                            &freeFlag_resolve_corruption=1
                            &freeFlagBlock_r_c=&curr_heap_mem
                            &freeflag=0 ; setting free_flag to 0 for printing its inforamtion in the output file
                            &exit=1
                         )
                         &sizeN=&sizeN-0x10
                     )
                  )
         
             )
             if (&handled==0)
             (
                print "<<<Heap Corruption Detected!!>>";
                gosub DoIntCheck &curr_heap_mem ; calling it again to udpate &calchashNext which is global
                print " Current Pad: required Pad Value: &calchashNext: &blkhash";
                &count=&count-1
                print "Memory block got corrupted is &curr_heap_mem ";
                &curruptedBlock=&curr_heap_mem-&size 
                if (&curr_heap_mem!=&curruptedBlock)
                (
                    print "Possible Overflown Block              : "+format.DECIMAL(8.,&count);
                    print "Overflown Block's Header address      : &curruptedBlock";  
                    print "Size allocated to the Overflown Block : "+format.DECIMAL(8., &size);
                    &flagbytes=V.VALUE(*((uint8*) &curruptedBlock + 3))
                    &freeflag=(&flagbytes&0x40)>>6
                    if (&freeFlagBlock_r_c==&curruptedBlock)
                    (
                        print " <<It seems that the ptr &freeFlagBlock_r_c+0x10 passed in mem_free() is the culprit >>"
                        &freeflag=0
                    )
                    if (&freeflag!=0x1)
                    (
                        &debug_info=V.VALUE(*((uint32*) (&curruptedBlock) + 2))
                        &debug_info_symbol= Y.NAME(D:&debug_info)
                        &stats_index=V.VALUE(*((uint32*) (&curruptedBlock) + 3))
                        if (&isHeapStats==1)
                        (
                         &tcb_ptr_symbol= V.STRING(&memheap_tls_to_tname[&stats_index])
                        )
                        &thread_id=&stats_index
                        print " This expected culprit(Overflown) block was allocated from function(i.e. Owner of it) = &debug_info_symbol , task = &tcb_ptr_symbol ,thread_id = &thread_id"
                    )
                    else
                    (
                       print "But this is a free block so it can not be the culprit and it should be there in the Free BINs "
                       print " please check for some other possiblities of this corruption "
                       print "  "
                    )
                )
                else
                (
                   print "*******Fisrt Block of the section number &number_of_sections got corrupted == &HeapVar.sections[&number_of_sections].start_addr ******** "
                )
                &count=&count+1 ; reset the counter back to this present number
                print " "
                ;check if there is BIT flip issue
                &iteration=0
                &freeFlagBitFlip=0;
                &bitCheckDone=0
                gosub DoIntCheck &curr_heap_mem ; calling it again to udpate &calchashNext which is global
                while ((&iteration<2)&&(&bitCheckDone==0)) ;do 2 iterations if bit flip occured on free_flag itself
                (
                    &hashDiff=&calchashNext^&blkhash
                    &bitNo=0
                    &bitsSum=0
                    &bitValue=0

                    while (&hashDiff!=0)
                    (
                      &temp=&hashDiff&1
                      &bitsSum=&bitsSum+(&temp&1)
                      &hashDiff=&hashDiff>>1;
                    )
                    if (&bitsSum==1)
                    (
                       if (&freeFlagBitFlip==1)
                       (
                           print "                   Bit flip is occured in **free_flag** of this block header            "
                       )
                      print "***there is total one bit flip in the corrupted block header that casued the integrity check fail***"
                      print " "
                      &bitCheckDone=1
                    )
                    if (&bitsSum==2)
                    (
                       if (&freeFlagBitFlip==1)
                       (
                          print "                   Bit flip is occured in **free_flag** of this block header            "
                       )
                       print "***there are total 2 bit flips in the corrupted block header that casued the integrity check fail***"
                       print " "
                       &bitCheckDone=1
                    )
                    if (&freeflag==1)
                    (
                       &calchash0=V.VALUE(*((uint16*) &curr_heap_mem))
                       &calchash2=V.VALUE(*((uint16*) &curr_heap_mem+1))
                       &calchash4=V.VALUE(*((uint16*) &curr_heap_mem+2))
                       &calchash6=V.VALUE(*((uint16*) &curr_heap_mem+3))
                       &calchashNext=&calchash2^&calchash4^&calchash6^&heapusedhash
                       &hashDiff=&calchashNext^&blkhash                      
                    )
                    if (&freeflag==0)
                    (
                       &calchash0=V.VALUE(*((uint16*) &curr_heap_mem))
                       &calchash2=V.VALUE(*((uint16*) &curr_heap_mem+1))
                       &calchash4=V.VALUE(*((uint16*) &curr_heap_mem+2))
                       &calchash6=V.VALUE(*((uint16*) &curr_heap_mem+3))
                       &calchash8=V.VALUE(*((uint16*) &curr_heap_mem+4))
                       &calchash10=V.VALUE(*((uint16*) &curr_heap_mem+5))
                       &calchashNext=&calchash2^&calchash4^&calchash6^&calchash8^&calchash10^&heapfreehash
                       &hashDiff=&calchashNext^&blkhash
                    )
                    &iteration=&iteration+1
                    &freeFlagBitFlip=1
               )
               if (&curr_heap_mem<&curr_heap_end)
               (
                   gosub FindNextValidBlock &curr_heap_mem &curr_heap_end
               )
               else if (&curr_heap_mem>=&curr_heap_end)
               (
                   &lastflag=0x01
                   print " it was the last memory block of this Section"
               )
           )

        )

       &size=V.VALUE(*((uint32*) &curr_heap_mem + 1))
       &extrabytes=V.VALUE(*((uint8*) &curr_heap_mem + 2))
       &flagbytes=V.VALUE(*((uint8*) &curr_heap_mem + 3))

       ;first 5 bits are sectionNumber
       &section_number=&flagbytes&0x1f
       &startflag=(&flagbytes&0x20)>>5
       &lastflag=(&flagbytes&0x80)>>7


       if (&DebugModeCheck==1)
       (
           if (&freeflag!=0x1)
           (
              if (&legacy!=0x0)
              (
                  &debug_info=V.VALUE(*((uint32*) &curr_heap_mem + 2))
              )
              else
              (
                   &stats_index=V.VALUE(*((uint32*) &curr_heap_mem + 3))
                  if (&DebugMethod==1)
                  (
                     &debug_info=V.VALUE(*((uint32*) &curr_heap_mem + 2))
                  )
                  if (&DebugMethod==2)
                  (
                      &debug_index=V.VALUE(*((uint32*) &curr_heap_mem + 2))
                      &stats_index=V.VALUE(&HeapVar->debug_array->db[&debug_index].stats_index)
                      &debug_info=V.VALUE(&HeapVar->debug_array->db[&debug_index].caller_ptr)
                  )
                  if (&isHeapStats==1)
                  (
                      &tcb_ptr_symbol= V.STRING(&memheap_tls_to_tname[&stats_index])
                      &thread_id=&stats_index
                  )
                  else
                  (
                      &tcb_ptr_symbol=""
                  )

              )
              &debug_info_symbol= Y.NAME(D:&debug_info)
           )
           else
           (
              &debug_info=V.VALUE(((mem_header_free_info_caller *) &curr_heap_mem)->caller) 
              &debug_info_symbol= Y.NAME(D:&debug_info)
           )
       )
       if (&lastBlockCorruption!=1)
       (
           &writestring=format.DECIMAL(8.,&count)
           &writestring="&writestring,"+"0x"+format.HEX(8., &curr_heap_mem)  
           if (&DebugModeCheck==1)
           (
              &writestring="&writestring,"+"0x"+format.HEX(8., &debug_info)
              if ("&debug_info_symbol"!="")
              ( 
                 &writestring="&writestring,"+""+"&debug_info_symbol"
              )
              else
              (
                 &writestring="&writestring,"+"NoSymbol"
              )
              if ("&tcb_ptr_symbol"!="")
              ( 
                  &writestring="&writestring,"+""+"&tcb_ptr_symbol"
                  &writestring="&writestring,"+""+format.DECIMAL(8., &thread_id)
              )
              else
              (
                 &writestring="&writestring,"+"NoSymbol"
                 &writestring="&writestring,"+""+format.DECIMAL(8., &thread_id)
              )
           )
           &writestring="&writestring,"+""+format.DECIMAL(8., &size)
           &writestring="&writestring,"+format.DECIMAL(8., &extrabytes)
           &writestring="&writestring,"+format.DECIMAL(2., &section_number)
           &writestring="&writestring,"+"0x"+format.HEX(1., &startflag)
           &writestring="&writestring,"+"0x"+format.HEX(1., &freeflag)
           &writestring="&writestring,"+"0x"+format.HEX(1., &lastflag)
           WRITE #1 "&writestring"
           &lastBlockCorruption=0
        )
       ;; check if next block's size is zero and falg as corruption
       &frd_offset_zero_corruption=0
       if ((&lastflag!=1)&&(&concatenatedWithPrevBlock==0))
       (
          &next_heap_block=&curr_heap_mem+&size
          &size2=V.VALUE(*((uint32*) &next_heap_block + 1))
          if ((&size2==0)&&(&next_heap_block<&curr_heap_end))
          (

               print "<<<Heap Corruption Detected! frd offset is set to zero ! for block : &next_heap_block >>";
               &frd_offset_zero_corruption=1
               print "Corrupted Block's Header address      : &next_heap_block";
               print "Possible Overflown Block              : "+format.DECIMAL(8.,&count);
               print "Overflown Block's Header address      : &curr_heap_mem";
               print "Size allocated to the Overflown Block : "+format.DECIMAL(8., &size);
               &flagbytes=V.VALUE(*((uint8*) &curr_heap_mem + 3))
               &freeflag=(&flagbytes&0x40)>>6
                if (&freeFlagBlock_r_c==&curr_heap_mem)
                (
                    print " <<It seems that the ptr &freeFlagBlock_r_c+0x10 passed in mem_free() is the culprit >>"
                    &freeflag=0 ; reset the freeflag  for this block since its under process in mem_free()

                )

                if (&freeflag!=0x1)
                (
                    &debug_info=V.VALUE(*((uint32*) (&curr_heap_mem) + 2))
                    &debug_info_symbol= Y.NAME(D:&debug_info)
                    &stats_index=V.VALUE(*((uint32*) (&curr_heap_mem) + 3))

                    if (&isHeapStats==1)
                    (
                         &tcb_ptr_symbol= V.STRING(&memheap_tls_to_tname[&stats_index])
                         &thread_id=&stats_index
                    )
                    &thread_id=&stats_index
                    print " This expected culprit(Overflown) block was allocated from function(i.e. Owner of it) = &debug_info_symbol , task = &tcb_ptr_symbol ,thread_id = &thread_id"
                )
                else
                (
                   print "   But this is a free block so it can not be the culprit and it should be there in the Free BINs "
                   print "   please check for some other possiblities of this corruption"
                   print "  "
                )

               if (&next_heap_block<&curr_heap_end)
               (
                   gosub FindNextValidBlock &next_heap_block &curr_heap_end
                   &curr_heap_mem=&NextValidBlock
                )
                else if (&curr_heap_mem>=&curr_heap_end)
                (
                    print "Aborting the script, it was the last memory block of heap"
                    CLOSE #1
                    if (&DebugModeCheck==1)
                    (
                       if (&DebugMethod==2)
                       (
                         gosub ProcOnlyMemdebugDb &OpT32FileMemDb &OpPlFile &BlockHeaderSize

                       )
                    )
                    enddo
                 )

          )
       )
       &concatenatedWithPrevBlock=0
       &flagbytes=V.VALUE(*((uint8*) &curr_heap_mem + 3))
       &curr_block_free_flag=(&flagbytes&0x40)>>6       
       &curr_block_section=&flagbytes&0x1f

       if ((&pre_block_free_flag==1)&&(&curr_block_free_flag==1)&&(&pre_block_section==&curr_block_section))
       (
          print " consecutive  free blocks found &pre_mem_block and &curr_heap_mem memory section = &pre_block_section"
          print " ----------- "
       )
       &pre_mem_block=&curr_heap_mem
       if (&corruptedBlock!=0)
       (
          if (&corruptedBlock<&curr_heap_end)
          (
             gosub FindNextValidBlock &corruptedBlock &curr_heap_end
          )
          else if (&corruptedBlock>=&curr_heap_end)
          (
             &lastflag=0x01
             print " it was the last memory block of this Section"
          )
          &corruptedBlock=0
       )
       else if (&frd_offset_zero_corruption==0)
       (
          &curr_heap_mem=&curr_heap_mem+&size
       )
       &frd_offset_zero_corruption=0
       &count=&count+1
       &flagbytes=V.VALUE(*((uint8*) &pre_mem_block + 3))
       &pre_block_free_flag=(&flagbytes&0x40)>>6
       &pre_block_section=&flagbytes&0x1f

    )

     &number_of_sections=&number_of_sections+1
     if (&number_of_sections<&total_number_of_sections)
     (
         &lastflag=0
         if (&lastBlockCorruption==1)
         (
            &lastBlockCorruption=0
            &count=&count-1
         )
         &curr_heap_mem=V.VALUE((mem_heap_type *) &HeapVar.sections[&number_of_sections].start_addr)
     )

 )
if (&lastBlockCorruption==1)
(
  &count=&count-1
)
&count=&count-1

print "  "
print "<<<<<<------------------------------------------------------------------------->>>>>"
&totalBlocks=V.VALUE((mem_heap_type *) &HeapVar.total_blocks)
print "       Total valid Heap Blocks expected in the heap = &totalBlocks"
print "       Total valid Heap Blocks could be detected(traversed) by the script= &count"
print "<<<<<<------------------------------------------------------------------------->>>>>"
print "  "

;information on incoming block 
print "!!<<< Memory Block passed in recent mem_free() call on *this* heap is = &incoming_Block >>>!!"
print "!! Below is more information on ptr passed in recent mem_free() (incoming block ptr) !!"

if (&incomBlockFound==1)
(
  if (&incomBlockInBinNo!=0xABCD)
  (
    print "!!The incoming block ptr is already a free block and present in free BIN no. = &incomBlockInBinNo   !!"
  )
  print "!!The incoming block belongs to setion no. = &incomBlockBelongsToSec of this heap                    !!"
  
)
else
(
  print "!!This was an invalid ptr passed in mem_free that dose not belong to the heap!!"
)
print "!!<<< ------------------------ end of incoming block info ------------------------ >>>!!"
print "   "
close #1
return ;End of walkHeap

walkStatsDB:
ENTRY &HeapVar &OpDir &MemStatsSize

if (&isHeapStats!=1)
(
;Debug stats is not present.
print "Debug stats not present, skipping the processing of debug stats"
return;
)
 OPEN #2 &OpT32FileStatsDb /Create 
; Important : Don't change this header! Used by Parser as is.
WRITE #2 "tcb_pointer,current_usage,max_usage" 
 &count=0;
 &writestring=""
 &thread_id=0
 &current_usage=0
 &max_usage=0
 &task_name=0x0

 
 while (&count!=&MemStatsSize)
 (
 ; First check for PAD 
 &max_usage=V.VALUE(&HeapVar.heapStatistics[&count].max_usage) 
 &current_usage= V.VALUE(&HeapVar.heapStatistics[&count].current_usage) 
 if (&max_usage!=0x0)      
 (
	&max_usage=V.VALUE(&HeapVar.heapStatistics[&count].max_usage)
	&task_name=V.STRING(&memheap_tls_to_tname[&count])
	&writestring="&task_name"
    ;&writestring=format.DECIMAL(8., &count)     
    &writestring="&writestring,"+""+format.DECIMAL(8., &current_usage)
    &writestring="&writestring,"+format.DECIMAL(8., &max_usage)
    WRITE #2 "&writestring"
 )
 &count=&count+1;
 )
close #2
return ;End of walkStatsDB


walkDebugDB:
ENTRY &HeapVar &OpDir &MemDebugSize

if (&DebugModeCheck!=1)
(
;Debug array is not present.
print "Debug array not present, skipping the processing of memdebug db"
return;
)
 OPEN #2 &OpT32FileMemDb /Create 
; Important : Don't change this header! Used by Parser as is.
WRITE #2 "Address,Size,CallerPtr,CallerPtr_Symbol,TCBPtr,TCBPtr_Symbol" 
 &ptr=0;
 &count=0;
 &writestring=""
 &caller_ptr=0x0
 &caller_ptr_symbol=""
 &stats_index=0
 &tcb_ptr_symbol=""
 &size=0
 
 while (&count!=&MemDebugSize)
 (
 ; First check for PAD 
 &ptr= V.VALUE(&HeapVar->debug_array->db[&count].ptr) 
 if (&ptr!=0x0)      
 (
    &size=V.VALUE(&HeapVar->debug_array->db[&count].size)
    &caller_ptr=V.VALUE(&HeapVar->debug_array->db[&count].caller_ptr) 
    &caller_ptr_symbol= Y.NAME(D:&caller_ptr)
    &stats_index=V.VALUE(&HeapVar->debug_array->db[&count].stats_index) 
    if (&isHeapStats==1)
    (
       &tcb_ptr_symbol= V.STRING(&memheap_tls_to_tname[&stats_index])
       &thread_id=&stats_index
    )
    else
    (
        &tcb_ptr_symbol=""
    )    
    &writestring="0x"+format.HEX(8., &ptr)     
    &writestring="&writestring,"+""+format.DECIMAL(8., &size)
    &writestring="&writestring,"+"0x"+format.HEX(8., &caller_ptr)
    if ("&caller_ptr_symbol"!="")
    ( 
        &writestring="&writestring,"+""+"&caller_ptr_symbol"
    )
    else
    (
        &writestring="&writestring,"+"NoSymbol"
    )
    if ("&tcb_ptr_symbol"!="")
    ( 
        &writestring="&writestring,"+"&tcb_ptr_symbol"
    )
    else
    (
        &writestring="&writestring,"+"NoSymbol"
    )
 WRITE #2 "&writestring"
 )
 &count=&count+1;
 )
close #2
return ;End of walkDebugDB



ProcHeap:
ENTRY &OpT32File &OpT32FileMemDb &OpPlFile &BlockHeaderSize
if ((&DebugModeCheck==1)&&(&DebugMethod==2))
(
print "     Executing perl &HeapParserScript -i &OpT32File -d &OpT32FileMemDb -o &OpPlFile -s &BlockHeaderSize"
os.area "perl &HeapParserScript -i &OpT32File -d &OpT32FileMemDb -o &OpPlFile -s &BlockHeaderSize"
)
else
(
print "     Executing perl &HeapParserScript -i &OpT32File -o &OpPlFile -s &BlockHeaderSize"
os.area "perl &HeapParserScript -i &OpT32File -o &OpPlFile -s &BlockHeaderSize"
)
print "     Parser finished executing."
print "     Please check &OpPlFile, &OpT32File and &OpT32FileMemDb for results"
return ;End of ProcHeap



ProcOnlyMemdebugDb:
ENTRY &OpT32FileMemDb &OpPlFile &BlockHeaderSize
print "     Executing perl &HeapParserScript -d &OpT32FileMemDb -o &OpPlFile -s &BlockHeaderSize"
os.area "perl &HeapParserScript -d &OpT32FileMemDb -o &OpPlFile -s &BlockHeaderSize"
print "     Parser finished executing."
print "     Please check &OpPlFile and &OpT32FileMemDb for results"
return ;End of ProcOnlyMemdebugDb


enddo
memheap_end:
do &CurrentDirectory\cmm_error.cmm  "memheap2_heapWalker_Latest.cmm"
enddo