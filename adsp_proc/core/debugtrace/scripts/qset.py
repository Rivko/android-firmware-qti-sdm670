from __future__ import print_function
import re
import inspect, os
import fileinput
import sys

def usage():
    print(
        """
QDSS SW Event Transalator

Usage:
    cat uart_log.txt| python qset.py  
       OR
    python  qset.py uart_log.txt

This script translates QDSS SW event ids from a UART log to 
corresponding string descriptions of the events. UART log has
events in this format

QSE 161 <arg1> <arg2> ...
QSEU 153 <arg1> <arg2> ...

Here event 161 is from root pd and 153 is from user pd.
The script uses the tracer_evt_tbl.h files generated by the SW event builder. 
The tracer_evt_tbl files in the same build as script is used.
So to get correct mappings for a build the script present in the

   slpi_proc/core/debugtrace/scripts 

folder of that build has to be used.

            """,
            file=sys.stderr)

class SWEventDB(object):

    ImageMap={
        'SENSOR':  'QSE',
        'SENSOR2': 'QSEU',
        }

    def __init__(self):
        self.eventTable={}
        self.tag = None
        self.source = None

    def GetEvent(self,source,eventId):
        return self.eventTable[(source,eventId)]

    # Get table of (event ID, enum value) tuples
    def GetMappingTable(self, source):
        table = list()

        for event in self.eventTable:
            if event[0] == source:
                table.append((event[1], self.eventTable[event][0]))

        return table

    def GetTag(self):
        return self.tag

    def GetSource(self):
        return self.source

    def Add(self,tracerEventFile):
        eventId=-1
        source=None
        tagFound = None
        event_line_item=re.compile('^.*{(.+),"(.*)".*}.*$')
        # TODO: This will eventually need to account for the quotes!
        source_line_item=re.compile('^\s*#define\s+EVENT_SUBSYSTEM\s+(\w+)\s*$')
        tag_line_item = re.compile('^\s*#define\s+EVENT_TABLE_TAG\s+\"(\d{12})\"\s*$')
        with open(tracerEventFile,'r') as f:
            for line in f.readlines():
                if (not tagFound):
                    t = tag_line_item.match(line)
                    if t:
                        self.tag = t.group(1)
                        tagFound = True
                if (not source):
                    m=source_line_item.match(line)
                    if m:
                        #use a mapping for event source if it is present
                        try:
                            source=self.ImageMap[m.group(1)] 
                        except:
                            source=m.group(1).upper()
                        self.source = source
                else:    
                    m=event_line_item.match(line)
                    if m:
                        eid=m.group(1).split('=')
                        event_name=eid[0]
                        if (event_name == "TRACER_EVENT_RESERVE_0"):
                            eventId += 1
                            continue
                        elif (event_name == "TRACER_EVENT_ID_MAX"):
                            continue
                        if (len(eid) > 1):
                            eventId=int(eid[1],0)
                        else:
                            eventId=eventId+1
                        self.eventTable[(source,eventId)]=(event_name, m.group(2))


def process_args(description,args_list):
    #Replace format specifier in the event description to python supported ones
    description = description.replace("%lld","%Ld")
    description = description.replace("%llu","%Lu")
    description = description.replace("%llx","%Lx")
    description = description.replace("%p","%%p")
		
    #Parse format specifiers to assign type to corresponding event arguments
    format_spec_pat = re.compile('(%d|%i|%u|%o|%x|%X|%s|%Ld|%Lu|%Lx)')
    format_spec_lst = re.findall(format_spec_pat, description)
    args = []
    i=0
    for pattern in format_spec_lst:
        if(pattern == "%s" ):
            args.append("<address not found>")
        elif(pattern == "%Ld" or pattern == "%Lu" or pattern == "%Lx"):
            #Little Endian Format
            num=int(args_list[i+1],16)
            num = num << 32
            num = num | int(args_list[i],16)
            args.append(num)
            #Double increment
            i=i+1
        else:
            args.append(int(args_list[i],16))
        i=i+1
    return (description % tuple(args))



if __name__ == '__main__':
    try :
        dir_name=os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
        tracer_tbl_root_pd=os.path.abspath(os.path.join(dir_name, '../tracer/inc/tracer_event_tbl.h'))
        tracer_tbl_user_pd=os.path.abspath(os.path.join(dir_name, '../tracer/inc/sensor/tracer_event_tbl.h'))
        swevent_db=SWEventDB();
        swevent_db.Add(tracer_tbl_root_pd)
        swevent_db.Add(tracer_tbl_user_pd)
        pd_name_map={
            'QSE' : 'sensor',
            'QSEU': 'sensor_user',
            }
    
        for line in fileinput.input():
            split_line = line.split()
            pd_name = split_line[0]
            event_id = split_line[1]
            event_id=int(event_id,16)
            args=split_line[2:]
            try: 
                (event_name,description)=swevent_db.GetEvent(pd_name,event_id)
                
                print("%15s %30s[0x%x]    %s" % (pd_name_map[pd_name],
                                                 event_name,
                                                 event_id,
                                                 process_args(description,args)))
            except Exception as e:
                print(line)
    except:
        usage()
        exit(1)

        

