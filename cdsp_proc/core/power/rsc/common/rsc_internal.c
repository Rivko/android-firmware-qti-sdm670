/*==============================================================================
  FILE:         rsc_internal.c

  OVERVIEW:     This file provides implementation of functions that usually are
                internal to rsc driver (in terms of functionality or data 
                access).

  DEPENDENCIES: None
  
                Copyright (c) 2016-2017 Qualcomm Technologies, Inc. (QTI).
                All Rights Reserved.
                Qualcomm Confidential and Proprietary.
                Export of this technology or software is regulated by the U.S. Government.
                Diversion contrary to U.S. law prohibited.
================================================================================
$Header: //components/rel/core.qdsp6/2.1.c4/power/rsc/common/rsc_internal.c#1 $
$DateTime: 2018/07/30 01:21:36 $
==============================================================================*/
#include "comdef.h"
#include "rsc.h"
#include "rsc_internal.h"
#include "rsc_seq_hal.h"
#include "rsc_hal_bsp.h"
#include "rsc_hwio.h"

/*=======================================================================
 *                           GLOBAL VARIABLES
 *======================================================================*/
/* References for the two RSC sequences */
extern uint32 g_rscParentSequence[];
extern uint32 g_rscChildSequence[];

/*=======================================================================
 *                       INTERNAL STATIC FUNCTIONS
 *======================================================================*/
/**
 * rsc_enable_ts_events
 *
 * @brief Enable/Disable time stamp unit associated with RSC instance(qdsp6/mss).
 *
 * @param baseAddr: RSC instance base address to which enable/disable the TS unit.
 * @param enable:   Boolean value to enable or disable the TS unit.
 *
 * @return RSC error code (@see rsc_result_t)
 */
static rsc_result_t rsc_enable_ts_events(uint32 baseAddr, boolean enable)
{
  uint32 i;
  
  for (i = 0; i < RSC_NUM_TIMESTAMPS; i++)
  {
    rsc_hal_enable_ts_unit(baseAddr, i, enable);

    /* Clear the spurious valid and overflow bit by reading the
     * RSC_TIMESTAMP_UNITm_TIMESTAMP_H. This is to clear the valid
     * and the overflow bit which could be generated by
     * the RSC_TIMESTAMP_UNITm_EN signal. */
    rsc_hal_get_ts_unit_h(baseAddr, i);
  }

  return RSC_SUCCESS;
}

/*=======================================================================
 *                           GLOBAL FUNCTIONS
 *======================================================================*/
/* 
 * rsc_setup
 */
rsc_result_t rsc_setup(void)
{
  uint32        i;
  uint32        nBr;
  rsc_t         *currMode;
  uint16        copied_cmds = 0;
  rsc_result_t  result      = RSC_SUCCESS;

  /* Program the command sequence to RSC sequencer memory. */
  for(i = 0; (i < g_rscCount) && (result == RSC_SUCCESS); i++)
  {
    currMode = &g_rscs[i];

    if(0 == currMode->sequence_size)
    {
      continue;
    }

    copied_cmds = rsc_hal_copy_cmd_seq(currMode->addr, currMode->sequence, currMode->sequence_size);

    if(0 == copied_cmds)
    {
      result = RSC_NO_SEQ_MEMORY;
    }
    else
    {
      result = rsc_enable_ts_events(currMode->addr, 1);
      
      /* Program branch addresses */
      if(RSC_SUCCESS == result)
      {
        if((NULL != currMode->branch_info) && (0 != currMode->br_count))
        {
          for(nBr = 0; nBr < currMode->br_count; nBr++)
          {
            rsc_hal_config_br_addr(currMode->addr, 
                                   currMode->branch_info[nBr].idx, 
                                   currMode->branch_info[nBr].offset);
          }

          /* Branch events under software control will set or clear it appropriatly.
           * Currently there is no control needed */
          rsc_hal_set_br_event(RSC_SS_BASE, 0);
        }
      }
    }
  }

  return result;
}

