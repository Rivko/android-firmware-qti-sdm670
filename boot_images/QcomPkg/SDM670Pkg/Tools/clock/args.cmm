;=============================================================================
;
;   MODULE:   args.cmm
;
;   PURPOSE:  Buffers command lines from T32 PRACTICE script users and returns
;             arguments seperated by whitespace. Also provides various common
;             utilities related to command line processing.
;
; ============================================================================
; Copyright (c) 2015 Qualcomm Technologies Incorporated.  All Rights Reserved.
; QUALCOMM Proprietary and Confidential. 
; ============================================================================
; $Header: //components/rel/boot.xf/2.1/QcomPkg/SDM670Pkg/Tools/clock/args.cmm#1 $
; $DateTime: 2017/09/18 09:26:13 $
; $Author: pwbldsvc $
; ============================================================================


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ARGS Commands:
;
;   "line" = PRACTICE macro string which isn't wrapped in double quotes. Full
;            lines can be read with "entry %LINE &<macro_name>".
;
;   See "args_<cmd>:" subroutine headers for more information.
;
;   (int)       create_client   <client_name> <area_name> [cmd_line]
;   (int)       switch_area     <client_id> <area_name>
;   (int)       reset_cmd_line  <client_id> [cmd_line]
;   (int)       set_opts        <client_id> <option_kwargs_line>
;   (int)       clear_opts      <client_id>
;
;   (string)    get_arg         <client_id> [prompt_line]
;   (string[2]) get_kwarg       <client_id> [prompt_line]
;   (int)       get_num_unread  <client_id>
;   (line)      get_cmd_line    <client_id> [unread_only_flag]
;
;   (int)       print_hist      <client_id>
;   (line)      get_hist_entry  <client_id> <entry_age>
;   (int)       get_hist_size   <client_id>
;
;   (string)    get_error       [client_id]
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ARGS Options:
;
;   All options are disabled by default.
;
;   help_cmd=[cmd]  - Sets the command string for the help sub. Requires a
;                     help sub to call.
;   help_sub=[sub]  - Sets the subroutine for the help command.
;
;   hist_cmd=[cmd]  - Sets the command string for the history operation.
;                     Requries a history sub to call.
;   hist_sub=[sub]  - Sets the subroutine for the history command.
;
;   nonempty_cmds=[0|1] - If set to one, repeats in-script prompts until a 
;                         non-empty arg is received from the user.
;
;   nonempty_vals=[0|1] - If set to one, "get_kwarg" returns an error
;                         upon detecting a value-less keyword argument (an
;                         error is always returned to key-less kwargs).
;
;   print_errors=[0|1]  - If set to one, error messages are printed to the
;                         I/O area automatically.
;
; ARGS Error Reporting:
;
;   All ARGS commands return ARGS_ERR upon detecting failures. Clients may
;   use the "get_error" ARGS command to query the error type that was
;   generated by the previous command.
;
; ARGS Error Type Strings:
;
;   NO_ERROR          => No error generated by the previous command.
;   NO_CMD            => Missing command.
;   INV_CMD           => Invalid command.
;
;   LONG_CMD_LINE     => Overlength user command line.
;   NO_CLIENT_ID      => Missing client ID.
;   INV_CLIENT_ID     => Invalid client ID (for non-"get_error" commands).
;
;   GET_ERR_INV_ID    => Invalid "get_error" client ID.
;
;   NO_CLIENT_NAME    => Missing client name argument.
;   INV_CLIENT_NAME   => Overlength client name.
;   NO_IO_AREA        => Missing I/O area argument.
;   INV_IO_AREA       => Nonexistent area or overlength name.
;
;   NO_OPT_KWARGS     => Missing option keyword arguments.
;   LONG_OPT_CMD      => Overlength help/history/quit command option.
;   DUP_OPT_KEY       => Duplicate option keyword.
;   INV_OPT_KEY       => Invalid option keyword.
;   INV_OPT_VAL       => Invalid option value.
;   OPT_CMD_NO_SUB    => Missing sub for help/history/quit command option.
;
;   NO_KWARG_KEY      => Key-less keyword argument detected by "get_kwarg".
;   NO_KWARG_VAL      => Value-less keyword argument detected by "get_kwarg"
;                        and the "nonempty_vals" option is enabled.
;
;   INV_HIST_AGE      => Invalid "get_hist_entry" entry-age.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;============================================================================;
;                             T32-GLOBAL MACROS                              ;
;============================================================================;

;
; Declare/initialize a global monotonically increasing ARGS client counter.
;
global &args_client_count
if ("&args_client_count"=="")
(
  &args_client_count=0.
)

;
; Declare/initialize a global ARGS macro to hold the previous ARGS error type.
; This error type macro is common to all clients. Its content is returned when
; no client ID is provided to "get_error". The primary use-cases are to
; trouble-shoot client creation errors and invalid client ID errors.
;
global &args_latest_error
if ("&args_latest_error"=="")
(
  &args_latest_error="NO_ERROR"
)


;============================================================================;
;                            SCRIPT-GLOBAL MACROS                            ;
;============================================================================;


;
; ARGS script file, absolute path.
;
local &ARGS_SCRIPT_FILE
&ARGS_SCRIPT_FILE=os.ppf()

;
; ARGS history buffer dimensions: (32 * 512 ) = 16 KB/client.
;
local &ARGS_MAX_HIST_ENTRIES
local &ARGS_HIST_ENTRY_MAX_LEN
local &ARGS_HIST_ENTRY_LAST_IDX
&ARGS_MAX_HIST_ENTRIES=32.      ; Max number of history entries.
&ARGS_HIST_ENTRY_MAX_LEN=512.   ; Max length of history entry.
&ARGS_HIST_ENTRY_LAST_IDX=(&ARGS_HIST_ENTRY_MAX_LEN-1.)

; ARGS error scratchpad (used for "ON ERROR gosub" execution detection).
local &err

;
; ARGS client global variable names.
;
local &gvar_name_client_name      ; => char[128.] "args_client_name_<ID>"
local &gvar_name_area_name        ; => char[128.] "args_area_name_<ID>"
local &gvar_name_client_error     ; => char[64.]  "args_err_<ID>"

local &gvar_name_cmd_line         ; => char[512.] "args_cmd_line_<ID>"
local &gvar_name_read_idx         ; => int        "args_read_idx_<ID>

local &gvar_name_help_cmd         ; => char[64.]  "args_help_cmd_<ID>"
local &gvar_name_help_sub         ; => char[64.]  "args_help_sub_<ID>"
local &gvar_name_hist_cmd         ; => char[64.]  "args_hist_cmd_<ID>"
local &gvar_name_hist_sub         ; => char[64.]  "args_hist_sub_<ID>"

local &gvar_name_nonempty_cmds    ; => int (bool) "args_non_empty_cmds_<ID>"
local &gvar_name_nonempty_vals    ; => int (bool) "args_non_empty_vals_<ID>"
local &gvar_name_print_errors_en  ; => int (bool) "args_print_errors_en_<ID>"

local &gvar_name_hist_en          ; => int (bool) "args_hist_en_<ID>"
local &gvar_name_hist_tip_idx     ; => int        "args_hist_tip_idx_<ID>"
local &gvar_name_num_hist_entries ; => int        "args_num_hist_entries_<ID>"

local &gvar_name_hist_buf         ; => char[32.][512.] "args_hist_buf_<ID>"


;============================================================================;
;                                    MAIN                                    ;
;============================================================================;

local &cmd_line
local &cmd
local &read_idx
local &cmd_ret
local &client_id

&client_id=""

; Grab the entire launch line.
entry %LINE &cmd_line

; Attempt to read the required command.
gosub args_get_next_substr_ws "&cmd_line" 0.
entry &cmd &read_idx
if ("&cmd"=="")
(
  &args_latest_error="NO_CMD"
  &cmd_ret="ARGS_ERR"
  goto args_record_errors
)

; Cut the command word out of the command line.
&cmd_line=string.cut("&cmd_line", &read_idx)

;
; Switch on the command.
;
if ("&cmd"=="create_client")            ; 'create_client'
(
  gosub args_create_client &cmd_line
  entry &cmd_ret
  goto args_record_errors
)

; Attempt to read the client ID.
gosub args_get_next_substr_ws "&cmd_line" 0.
entry &client_id &read_idx

; Validate the client ID.
if ("&client_id"!="")
(
  ON ERROR gosub
  (
    return
  )

  if ((&client_id<0)||(&client_id>=&args_client_count))
  (
    ; Note that if 'client_id' isn't numeric, PRACTICE will still pass into
    ; this block as part of its behavior for invalid flow-control commands.
    &client_id=""
    if ("&cmd"=="get_error")
    (
      &args_latest_error="GET_ERR_INV_ID"
    )
    else
    (
      &args_latest_error="INV_CLIENT_ID"
    )

    &cmd_ret="ARGS_ERR"
    goto args_record_errors
  )
)

;
; Continue switching on the command.
;
if ("&cmd"=="get_error")                ; 'get_error'
(
  ; Set the global variable names for the client.
  if ("&client_id"!="")
  (
    gosub args_set_gvar_names &client_id
  )

  gosub args_get_error &client_id
  entry &cmd_ret
  goto args_record_errors
)

; Require a client ID for all following commands.
if ("&client_id"=="")
(
  &args_latest_error="NO_CLIENT_ID"
  &cmd_ret="ARGS_ERR"
  goto args_record_errors
)

; Cut the client ID out of the command line.
&cmd_line=string.cut("&cmd_line", &read_idx)

; Set the global variable names for the client.
gosub args_set_gvar_names &client_id

;
; Continue switching on the command.
;
&cmd_ret=""
if ("&cmd"=="switch_area")              ; 'switch_area'
(
  gosub args_switch_area &cmd_line
)
else if ("&cmd"=="reset_cmd_line")      ; 'reset_cmd_line'
(
  gosub args_reset_cmd_line &cmd_line
)
else if ("&cmd"=="set_opts")            ; 'set_opts'
(
  gosub args_set_opts &cmd_line
)
else if ("&cmd"=="clear_opts")          ; 'clear_opts'
(
  gosub args_clear_opts
)
else if ("&cmd"=="get_arg")             ; 'get_arg'
(
  gosub args_get_arg &cmd_line
)
else if ("&cmd"=="get_kwarg")           ; 'get_kwarg'
(
  gosub args_get_kwarg &cmd_line
)
else if ("&cmd"=="get_cmd_line")        ; 'get_cmd_line'
(
  gosub args_get_cmd_line &cmd_line
)
else if ("&cmd"=="get_num_unread")      ; 'get_num_unread'
(
  gosub args_get_num_unread
)
else if ("&cmd"=="print_hist")          ; 'print_hist'
(
  gosub args_print_hist
)
else if ("&cmd"=="get_hist_entry")      ; 'get_hist_entry'
(
  gosub args_get_hist_entry &cmd_line
)
else if ("&cmd"=="get_hist_size")       ; 'get_hist_size'
(
  gosub args_get_hist_size
)
else
(
  ; Invalid command.
  print %ERROR "ERROR [&ARGS_SCRIPT_FILE]:"
  print %ERROR "  Unknown ARGS command detected ('&cmd')."

  &args_latest_error="INV_CMD"
  &cmd_ret="ARGS_ERR"
)

if ("&cmd_ret"=="")
(
  entry %LINE &cmd_ret
  &cmd_ret=string.trim("&cmd_ret")
)

;
; Record error states.
;
args_record_errors:

if ("&cmd_ret"=="ARGS_ERR")
(
  if ("&client_id"!="") ; Non-empty 'client_id' => gvar names are set.
  (
    var.if (\&gvar_name_print_errors_en)
    (
      gosub args_print_error 
    )
  )
)
else
(
  &args_latest_error="NO_ERROR"
)

if ("&client_id"!="") ; Non-empty 'client_id' => gvar names are set.
(
  var.assign \&gvar_name_client_error = "&args_latest_error"
)

;
; Return the command's status to the caller script.
;
enddo &cmd_ret


;============================================================================;
;                            UTILITY SUB-ROUTINES                            ;
;============================================================================;

;-----------------------------------------------------------------------------
;
; SUB:      void args_print_error ( void )
;
; INFO:     Prints the ARGS error type and a short description to the client's
;           I/O area.
;
; RETURNS:  Void.
;
;-----------------------------------------------------------------------------
args_print_error:
(
  print %ERROR "ERROR [&ARGS_SCRIPT_FILE]:"

  ;
  ; Switch on the latest error type.
  ;
  if ("&args_latest_error"=="NO_CMD")
  (
    print %ERROR "  'NO_CMD' => Missing command."
  )
  else if ("&args_latest_error"=="INV_CMD")
  (
    print %ERROR "  'INV_CMD' => Invalid command."
  )
  else if ("&args_latest_error"=="LONG_CMD_LINE")
  (
    print %ERROR "  'LONG_CMD_LINE' => Overlength user command line."
  )
  else if ("&args_latest_error"=="NO_CLIENT_ID")
  (
    print %ERROR "  'NO_CLIENT_ID' => Missing client ID."
  )
  else if ("&args_latest_error"=="INV_CLIENT_ID")
  (
    print %ERROR "  'INV_CLIENT_ID' => Invalid client ID (for non-'get_error' commands)."
  )
  else if ("&args_latest_error"=="GET_ERR_INV_ID")
  (
    print %ERROR "  'GET_ERR_INV_ID' => Invalid 'get_error' client ID."
  )
  else if ("&args_latest_error"=="NO_CLIENT_NAME")
  (
    print %ERROR "  'NO_CLIENT_NAME' => Missing client name argument."
  )
  else if ("&args_latest_error"=="INV_CLIENT_NAME")
  (
    print %ERROR "  'INV_CLIENT_NAME' => Overlength client name."
  )
  else if ("&args_latest_error"=="NO_IO_AREA")
  (
    print %ERROR "  'NO_IO_AREA' => Missing I/O area argument."
  )
  else if ("&args_latest_error"=="INV_IO_AREA")
  (
    print %ERROR "  'INV_IO_AREA' => Nonexistent area or overlength name."
  )
  else if ("&args_latest_error"=="NO_OPT_KWARGS")
  (
    print %ERROR "  'NO_OPT_KWARGS' => Missing option keyword arguments."
  )
  else if ("&args_latest_error"=="LONG_OPT_CMD")
  (
    print %ERROR "  'LONG_OPT_CMD' => Overlength help/history/quit command option."
  )
  else if ("&args_latest_error"=="DUP_OPT_KEY")
  (
    print %ERROR "  'DUP_OPT_KEY' => Duplicate option keyword."
  )
  else if ("&args_latest_error"=="INV_OPT_KEY")
  (
    print %ERROR "  'INV_OPT_KEY' => Invalid option keyword."
  )
  else if ("&args_latest_error"=="INV_OPT_VAL")
  (
    print %ERROR "  'INV_OPT_VAL' => Invalid option value."
  )
  else if ("&args_latest_error"=="OPT_CMD_NO_SUB")
  (
    print %ERROR "  'OPT_CMD_NO_SUB' => Missing sub for help/history/quit command option."
  )
  else if ("&args_latest_error"=="NO_KWARG_KEY")
  (
    print %ERROR "  'NO_KWARG_VAL' => Key-less keyword argument detected by 'get_kwarg'."
  )
  else if ("&args_latest_error"=="NO_KWARG_VAL")
  (
    print %ERROR "  'NO_KWARG_VAL' => Value-less keyword argument detected by 'get_kwarg'."
  )
  else if ("&args_latest_error"=="INV_HIST_AGE")
  (
    print %ERROR "  'INV_HIST_AGE' => Invalid 'get_hist_entry' entry-age."
  )
  else
  (
    print %ERROR "  Unknown ARGS error!"
  )

  return
)

;-----------------------------------------------------------------------------
;
; SUB:      int args_var_assign_string
;           (
;             string var_buf_name,
;             int var_buf_len,
;             line str_in
;           )
;
; INFO:     Fills a character buffer with a zero-terminated string. Truncates
;           the string to fit within the buffer variable if necessary.
;
;           The 'str_in' line should not be wrapped in double quotes.
;
; RETURNS:  -1 if the string is truncated or a parameter is missing, else 0.
;
; NOTES:    Doubles all '\' for var.string() reads. Any time a user string may
;           contain '\', this sub should be used instead of "var.assign".
;
;           The paramaters are read as a single line to prevent "var.assign"
;           issues with double quotes.
;
;-----------------------------------------------------------------------------
args_var_assign_string:
(
  local &read_idx
  local &var_buf_name
  local &var_buf_len
  local &str_in
  local &str_in_len

  entry %LINE &str_in

  ; Extract the variable buffer symbol name.
  gosub args_get_next_substr_ws "&str_in" 0.
  entry &var_buf_name &read_idx
  if ("&var_buf_name"=="")
  (
    return -1.
  )

  ; Extract the buffer length.
  gosub args_get_next_substr_ws "&str_in" &read_idx
  entry &var_buf_len &read_idx
  if ("&var_buf_len"=="")
  (
    return -1.
  )

  ; Isolate the input string.
  &str_in=string.cut("&str_in", &read_idx)
  &str_in=string.trim("&str_in")

  ; Double each '\' to ensure proper var.string() read interpretation.
  &str_in=string.replace("&str_in", "\", "\\", 0.)

  ; Trim the string to prevent buffer overflow.
  &str_in_len=string.length("&str_in")
  &str_in=string.mid("&str_in", 0, &var_buf_len-1)

  ; Assign the input string to the buffer variable.
  var.assign \&var_buf_name = "&str_in"

  ; Return -1 iff the input string was truncated.
  if (&str_in_len>=&var_buf_len)
  (
    return -1.
  )
  else
  (
    return 0.
  )
)

;-----------------------------------------------------------------------------
;
; SUB:      string args_get_client_name ( int client_id )
;
; INFO:     Gets the 'client-name' global variable name from the client ID.
;
; RETURNS:  The ARGS client name global variable name.
;
; NOTES:    Does not verify the client ID.
;
;-----------------------------------------------------------------------------
args_get_client_name:
(
  local &gvar_name
  local &client_id

  entry &client_id

  ;
  ; Convert ID to decimal format to ensure consistency.
  ;
  &client_id=format.decimal(0, &client_id)

  ;
  ; Set the global variable names.
  ;
  &gvar_name="args_client_name_&client_id"

  return &gvar_name
)

;-----------------------------------------------------------------------------
;
; SUB:      void args_set_gvar_names ( int client_id )
;
; INFO:     Sets the global T32 variable names for the client.
;
; RETURNS:  Void.
;
; NOTES:    Does not verify the client ID.
;
;-----------------------------------------------------------------------------
args_set_gvar_names:
(
  local &suffix
  local &client_id

  entry &client_id

  ;
  ; Convert ID to decimal format to ensure consistency.
  ;
  &suffix=format.decimal(0, &client_id)

  ;
  ; Set the global variable names.
  ;
  gosub args_get_client_name &client_id
  entry &gvar_name_client_name

  &gvar_name_area_name="args_area_name_&suffix"
  &gvar_name_client_error="args_err_&suffix"

  &gvar_name_cmd_line="args_cmd_line_&suffix"
  &gvar_name_read_idx="args_read_idx_&suffix"

  &gvar_name_help_cmd="args_help_cmd_&suffix"
  &gvar_name_help_sub="args_help_sub_&suffix"
  &gvar_name_hist_cmd="args_hist_cmd_&suffix"
  &gvar_name_hist_sub="args_hist_sub_&suffix"

  &gvar_name_nonempty_cmds="args_non_empty_cmds_&suffix"
  &gvar_name_nonempty_vals="args_non_empty_vals_&suffix"
  &gvar_name_print_errors_en="args_print_errors_en_&suffix"

  &gvar_name_hist_en="args_hist_en_&suffix"
  &gvar_name_hist_tip_idx="args_hist_tip_idx_&suffix"
  &gvar_name_num_hist_entries="args_num_hist_entries_&suffix"

  &gvar_name_hist_buf="args_hist_buf_&suffix"

  return
)

;-----------------------------------------------------------------------------
;
; SUB:      string args_verify_and_select_area ( int area_name )
;
; INFO:     Verifies that an area name is valid and the area exists. The area
;           is selected as part of the verification.
;
; RETURNS:  NO_ERROR      => Valid area was selected.
;           NO_IO_AREA    => Missing area name parameter.
;           INV_IO_AREA   => Area doesn't exist or invalid/overlength name.
;
; NOTES:    ARGS I/O area names must be less than 128 characters.
;           If in invalid area is detected, 'args_latest_error' is updated.
;
;-----------------------------------------------------------------------------
args_verify_and_select_area:
(
  local &area_name
  entry &area_name

  ; Verify area name length is valid.
  if ("&area_name"=="")
  (
    return NO_IO_AREA
  )

  &err=string.length("&area_name")
  if (&err>=128.)
  (
    return INV_IO_AREA
  )

  ; Verify that the given I/O area already exists.
  ON ERROR gosub
  (
    &err="!"
    return
  )

  &err=""
  area.select &area_name

  if ("&err"=="!")
  (
    return INV_IO_AREA
  )
  else
  (
    return NO_ERROR
  )
)

;-----------------------------------------------------------------------------
;
; SUB:      string args_get_next_substr_ws
;           (
;             string src_str,
;             int read_idx
;           )
;
; INFO:     Returns the next sub-string word from a source string, or nothing
;           if there is no such word. The words are split by spaces.
;
; RETURNS:  {sub_str, read_idx} -OR- Nothing.
;
;           Example: <gosub args_get_next_substr_ws "a  bc  de" 1.>
;                     Returns "bc 5" (sans quotes).
;
;-----------------------------------------------------------------------------
args_get_next_substr_ws:
(
  local &src_str
  local &src_len
  local &read_idx
  local &sub_str
  local &start_idx

  entry &src_str &read_idx

  if (&read_idx<0)
  (
    ; Negative read index--return empty string (and no index).
    return
  )

  &src_len=string.length(&src_str)

  ; Find the start of non-whitespace segment.
  while (&read_idx<&src_len)
  (
    if (string.char(&src_str, &read_idx)!=' ')
    (
      &start_idx=&read_idx
      goto args__get_substr_ws_find_end
    )

    &read_idx=&read_idx+1
  )

  ; No non-whitespace found--return empty string (and no index).
  return

args__get_substr_ws_find_end:

  ; Find the end of non-whitespace segment.
  &read_idx=&read_idx+1
  while (&read_idx<&src_len)
  (
    if (string.char(&src_str, &read_idx)==' ')
    (
      ; Cut out leading and trailing whitespace
      &sub_str=string.mid(&src_str, &start_idx, &read_idx-&start_idx)

      goto args__get_substr_ws_return
    )

    &read_idx=&read_idx+1
  )

  ; No trailing white-space found--cut out any leading whitespace.
  &sub_str=string.cut(&src_str, &start_idx)

args__get_substr_ws_return:

  return &sub_str &read_idx
)

;-----------------------------------------------------------------------------
;
; SUB:      int args_get_circ_buf_idx ( int base_idx, int delta, int buf_len )
;
; INFO:     Returns the index of an entry in a circular buffer.
;
; RETURNS:  Circular buffer index.
;
;-----------------------------------------------------------------------------
args_get_circ_buf_idx:
(
  local &ret_idx
  local &base_idx
  local &delta
  local &buf_len

  entry &base_idx &delta &buf_len

  &base_idx=(&base_idx%&buf_len)
  &delta=(&delta%&buf_len)
  &ret_idx=(&base_idx+&delta)

  if (&ret_idx<0)
  (
    &ret_idx=(&buf_len+&ret_idx)
  )
  else if (&ret_idx>=&buf_len)
  (
    &ret_idx=(&ret_idx-&buf_len)
  )

  return &ret_idx
)

;-----------------------------------------------------------------------------
;
; SUB:      void args_add_hist_entry ( string new_hist_entry )
;
; INFO:     Adds a history entry. Does not add redundant/empty entries.
;
; RETURNS:  Void.
;
;-----------------------------------------------------------------------------
args_add_hist_entry:
(
  local &idx
  local &youngest_idx
  local &match_idx
  local &match_hist_entry
  local &hist_entry_newer
  local &hist_entry_older
  local &num_entries
  local &tip_idx
  local &hist_cmd

  local &new_hist_entry
  entry &new_hist_entry

  ; Trim the line and short-circuit if the line is empty or a history command.
  &new_hist_entry=string.trim(&new_hist_entry)
  &hist_cmd=var.string(\&gvar_name_hist_cmd)
  if (("&new_hist_entry"=="")||("&new_hist_entry"=="&hist_cmd"))
  (
    return
  )

  &tip_idx=var.value(\&gvar_name_hist_tip_idx)

  ; Truncate history entries to fit within the buffer.
  &new_hist_entry=string.mid("&new_hist_entry", 0., 511.)

  ; Check if the exact entry is already stored in history.
  &match_idx=0
  while (&match_idx<&ARGS_MAX_HIST_ENTRIES)
  (
    &match_hist_entry=var.string(\&gvar_name_hist_buf[&match_idx])
    if ("&match_hist_entry"=="&new_hist_entry")
    (
      ; Match found--reorder entries.
      goto args__add_hist_entry_reorder
    )

    &match_idx=&match_idx+1
  )

  ; Add a new entry to the history buffer.
  gosub args_var_assign_string &gvar_name_hist_buf[&tip_idx] 512. &new_hist_entry
  &num_entries=var.value(\&gvar_name_num_hist_entries)
  if (&num_entries<&ARGS_MAX_HIST_ENTRIES)
  (
    ; Increment the number of history entries for the client.
    &num_entries=&num_entries+1
    var.assign \&gvar_name_num_hist_entries = &num_entries
  )
  gosub args_get_circ_buf_idx &tip_idx 1. &ARGS_MAX_HIST_ENTRIES
  entry &tip_idx
  var.assign \&gvar_name_hist_tip_idx = &tip_idx

  return

args__add_hist_entry_reorder:

  gosub args_get_circ_buf_idx &tip_idx -1. &ARGS_MAX_HIST_ENTRIES
  entry &youngest_idx

  ; Shift the offset entries up in age.
  &idx=&youngest_idx
  &hist_entry_newer=var.string(\&gvar_name_hist_buf[&idx])
  while (&idx!=&match_idx)
  (
    gosub args_get_circ_buf_idx &idx -1. &ARGS_MAX_HIST_ENTRIES
    entry &idx

    &hist_entry_older=var.string(\&gvar_name_hist_buf[&idx])
    gosub args_var_assign_string &gvar_name_hist_buf[&idx] 512. &hist_entry_newer

    &hist_entry_newer="&hist_entry_older"
    &idx=&idx
  )

  ; Move the matched history entry to the youngest history entry.
  gosub args_var_assign_string &gvar_name_hist_buf[&youngest_idx] 512. &match_hist_entry

  return
)


;============================================================================;
;                         ARGS COMMAND SUB-ROUTINES                          ;
;============================================================================;

;-----------------------------------------------------------------------------
;
; SUB:      int args_create_client
;           ( 
;             string  client_name_in,
;             string  initial_io_area_name,
;             line  initial_cmd_line
;           )
;
; INFO:     Initializes an ARGS client. If the client already exists, it is
;           re-initialized.
;
;           Do not wrap any of the paramaters in double quotes.
;           The given I/O area is selected in order to confirm that it exists.
;           The client is responsible for creating this I/O area.
;
; RETURNS:  A client ID upon success or "ARGS_ERR" upon failure.
;
; ERRORS:   {NO_CLIENT_NAME, INV_CLIENT_NAME,
;           NO_IO_AREA, INV_IO_AREA, LONG_CMD_LINE}.
;
; NOTES:    The client and I/O area names must be less than 128 characters.
;           The paramaters are read as a single line in order to avoid double
;           quote issues which arise otherwise.
;
;-----------------------------------------------------------------------------
args_create_client:
(
  local &resident_client_name
  local &client_id
  local &idx
  local &read_idx
  local &client_name_var
  local &client_is_new

  local &client_name_in
  local &initial_io_area_name
  local &initial_cmd_line

  entry %LINE &initial_cmd_line

  ; First extract the client name.
  gosub args_get_next_substr_ws "&initial_cmd_line" 0.
  entry &client_name_in &read_idx
  if ("&client_name_in"=="")
  (
    &args_latest_error="NO_CLIENT_NAME"
    return ARGS_ERR
  )

  ; Check for overlength client name.
  if (&read_idx>=128.)
  (
    &args_latest_error="INV_CLIENT_NAME"
    return ARGS_ERR
  )

  ; Next extract the I/O area name.
  gosub args_get_next_substr_ws "&initial_cmd_line" &read_idx
  entry &initial_io_area_name &read_idx

  ; Check that the area is valid.
  gosub args_verify_and_select_area &initial_io_area_name
  entry &args_latest_error
  if ("&args_latest_error"!="NO_ERROR")
  (
    return ARGS_ERR
  )

  ; Isolate and trim the initial command line.
  &initial_cmd_line=string.cut("&initial_cmd_line", &read_idx)
  &initial_cmd_line=string.trim("&initial_cmd_line")

  ;
  ; Check if the client already exists.
  ;
  &client_is_new=0.
  &client_id=0
  while (&client_id<&args_client_count)
  (
    gosub args_get_client_name &client_id
    entry &client_name_var

    &resident_client_name=var.string(\&client_name_var)

    if ("&client_name_in"=="&resident_client_name")
    (
      goto args__create_client_gvar_names
    )

    &client_id=&client_id+1
  )

  ; Client does not exist--increment the client count.
  &args_client_count=&args_client_count+1
  &client_is_new=1.

args__create_client_gvar_names:

  ; Set the global variable names for the client.
  gosub args_set_gvar_names &client_id

  if (&client_is_new!=0.)
  (
    ;
    ; Client doesn't already exist--create new client global variables.
    ;
    var.newglobal char[128.] \&gvar_name_client_name
    var.newglobal char[128.] \&gvar_name_area_name
    var.newglobal char[64.] \&gvar_name_client_error

    var.newglobal char[512.] \&gvar_name_cmd_line
    var.newglobal int \&gvar_name_read_idx

    var.newglobal char[64.] \&gvar_name_help_cmd
    var.newglobal char[64.] \&gvar_name_help_sub
    var.newglobal char[64.] \&gvar_name_hist_cmd
    var.newglobal char[64.] \&gvar_name_hist_sub

    var.newglobal int \&gvar_name_nonempty_cmds
    var.newglobal int \&gvar_name_nonempty_vals
    var.newglobal int \&gvar_name_print_errors_en

    var.newglobal int \&gvar_name_hist_en
    var.newglobal int \&gvar_name_hist_tip_idx
    var.newglobal int \&gvar_name_num_hist_entries

    var.newglobal char[32.][512.] \&gvar_name_hist_buf

    ; Start clients with an empty history.
    var.assign \&gvar_name_hist_en = 0
    var.assign \&gvar_name_hist_tip_idx = 0
    var.assign \&gvar_name_num_hist_entries = 0

    &idx=0.
    while (&idx<32.)
    (
      var.assign \&gvar_name_hist_buf[&idx][0] = 0
      &idx=&idx+1.
    )
  )

  ;
  ; Initialize the client's global state.
  ;
  gosub args_var_assign_string &gvar_name_client_name 128. &client_name_in
  entry &idx
  if (&idx==-1.) ; Need to double check length due to '\' doubling.
  (
    &args_latest_error="INV_CLIENT_NAME"
    return ARGS_ERR
  )

  gosub args_var_assign_string &gvar_name_area_name 128. &initial_io_area_name
  entry &idx
  if (&idx==-1.) ; Need to double check length due to '\' doubling.
  (
    &args_latest_error="INV_IO_AREA"
    return ARGS_ERR
  )

  gosub args_var_assign_string &gvar_name_cmd_line 512. &initial_cmd_line
  entry &idx
  if (&idx==-1.) ; Need to double check length due to '\' doubling.
  (
    &args_latest_error="LONG_CMD_LINE"
    return ARGS_ERR
  )

  var.assign \&gvar_name_client_error = "NO_ERROR"
  var.assign \&gvar_name_read_idx = 0

  var.assign \&gvar_name_help_cmd[0] = 0
  var.assign \&gvar_name_help_sub[0] = 0
  var.assign \&gvar_name_hist_cmd[0] = 0
  var.assign \&gvar_name_hist_sub[0] = 0

  var.assign \&gvar_name_nonempty_cmds = 0
  var.assign \&gvar_name_nonempty_vals = 0
  var.assign \&gvar_name_print_errors_en = 0

  ; Unconditionally record the launch line in history.
  gosub args_add_hist_entry "&initial_cmd_line"

  ;
  ; Return the initialized client's ID.
  ;
  return &client_id
)

;-----------------------------------------------------------------------------
;
; SUB:      int args_switch_area ( string new_area )
;
; INFO:     Switches the client's I/O area.
;           Do not wrap 'new_area' parameter in double quotes.
;
; RETURNS:  Nothing upon success, else "ARGS_ERR".
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID, NO_IO_AREA, INV_IO_AREA}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;-----------------------------------------------------------------------------
args_switch_area:
(
  local &new_area
  entry &new_area

  ; Verify and select the area.
  gosub args_verify_and_select_area &new_area
  entry &args_latest_error
  if ("&args_latest_error"!="NO_ERROR")
  (
    return ARGS_ERR
  )

  ; Record the new client I/O area.
  gosub args_var_assign_string &gvar_name_area_name 128. &new_area
  entry &idx
  if (&idx==-1.) ; Need to double check length due to '\' doubling.
  (
    &args_latest_error="INV_IO_AREA"
    return ARGS_ERR
  )

  ;
  ; Return success.
  ;
  return
)

;-----------------------------------------------------------------------------
;
; SUB:      int args_reset_cmd_line ( [line new_cmd_line] )
;
; INFO:     Resets the buffered ARGS command line.
;           Do not wrap the 'new_cmd_line' parameter in double quotes. 
;
; RETURNS:  Nothing upon success, else "ARGS_ERR".
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID, LONG_CMD_LINE}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;-----------------------------------------------------------------------------
args_reset_cmd_line:
(
  local &idx
  local &new_cmd_line
  entry %LINE &new_cmd_line

  ;
  ; Set the command line buffer state.
  ;
  gosub args_var_assign_string &gvar_name_cmd_line 512. &new_cmd_line
  entry &idx
  if (&idx==-1.)
  (
    &args_latest_error="LONG_CMD_LINE"
    return ARGS_ERR
  )

  ;
  ; Record the new command line in history.
  ;
  &new_cmd_line=string.trim("&new_cmd_line")
  if ("&new_cmd_line"!="")
  (
    var.if (\&gvar_name_hist_en!=0)
    (
      gosub args_add_hist_entry "&new_cmd_line"
    )
  )

  var.assign \&gvar_name_read_idx = 0

  ;
  ; Return success.
  ;
  return
)

;-----------------------------------------------------------------------------
;
; SUB:      int args_set_opts ( line opts )
;
; INFO:     Sets ARGS options. Any unspecified options are left unmodified.
;           All options are initially disabled by default.
;
;           Do not wrap the 'opts' parameter in double quotes. 
;           See "ARGS Options:" for more information.
;
; RETURNS:  Nothing upon success, else "ARGS_ERR".
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID, NO_OPT_KWARGS, DUP_OPT_KEY
;           INV_OPT_KEY, INV_OPT_VAL, LONG_OPT_CMD, OPT_CMD_NO_SUB}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;           Help/history/quit commands must be less than 64 characters.
;
;-----------------------------------------------------------------------------
args_set_opts:
(
  local &idx
  local &help_cmd
  local &help_sub
  local &hist_cmd
  local &hist_sub
  local &nonempty_cmds
  local &nonempty_vals
  local &print_errors

  local &opts
  entry %LINE &opts

  ;
  ; Return failure if no options are given.
  ;
  &opts=string.trim("&opts")
  if ("&opts"=="")
  (
    &args_latest_error="NO_OPT_KWARGS"
    return ARGS_ERR
  )

  ;
  ; Attempt to extract option keword arguments.
  ;
  &help_cmd=string.ScanAndExtract("&opts", "help_cmd=", "INV_OPT")
  &help_sub=string.ScanAndExtract("&opts", "help_sub=", "INV_OPT")

  &hist_cmd=string.ScanAndExtract("&opts", "hist_cmd=", "INV_OPT")
  &hist_sub=string.ScanAndExtract("&opts", "hist_sub=", "INV_OPT")

  &nonempty_cmds=string.ScanAndExtract("&opts", "nonempty_cmds=", "INV_OPT")
  &nonempty_vals=string.ScanAndExtract("&opts", "nonempty_vals=", "INV_OPT")
  &print_errors=string.ScanAndExtract("&opts", "print_errors=", "INV_OPT")

  ;
  ; Process options.
  ;
  if ("&help_sub"!="INV_OPT")
  (
    ; Record the client's option.
    gosub args_var_assign_string &gvar_name_help_sub 64. &help_sub
    entry &idx
    if (&idx==-1.)
    (
      &args_latest_error="LONG_OPT_CMD"
      return ARGS_ERR
    )

    ; Remove the option from the options line.
    &opts=string.replace("&opts", "help_sub=&help_sub", "", 1)

    ; Check for duplicate option.
    &idx=string.scan("&opts", "help_sub=", 0)
    if (&idx!=-1.)
    (
      &args_latest_error="DUP_OPT_KEY"
      return ARGS_ERR
    )
  )
  if ("&help_cmd"!="INV_OPT")
  (
    ; Require a subroutine for the command option.
    &help_sub=var.string(\&gvar_name_help_sub)
    if (("&help_cmd"!="")&&("&help_sub"==""))
    (
      print %ERROR "ERROR [&ARGS_SCRIPT_FILE]:"
      print %ERROR "  Help sub is required for help command option (help_cmd='&help_cmd')."

      &args_latest_error="OPT_CMD_NO_SUB"
      return ARGS_ERR
    )

    ; Record the client's option.
    gosub args_var_assign_string &gvar_name_help_cmd 64. &help_cmd
    entry &idx
    if (&idx==-1.)
    (
      &args_latest_error="LONG_OPT_CMD"
      return ARGS_ERR
    )

    ; Remove the option from the options line.
    &opts=string.replace("&opts", "help_cmd=&help_cmd", "", 1)

    ; Check for duplicate option.
    &idx=string.scan("&opts", "help_cmd=", 0)
    if (&idx!=-1.)
    (
      &args_latest_error="DUP_OPT_KEY"
      return ARGS_ERR
    )
  )
  if ("&hist_sub"!="INV_OPT")
  (
    ; Record the client's option.
    gosub args_var_assign_string &gvar_name_hist_sub 64. &hist_sub
    entry &idx
    if (&idx==-1.)
    (
      &args_latest_error="LONG_OPT_CMD"
      return ARGS_ERR
    )

    ; Remove the option from the options line.
    &opts=string.replace("&opts", "hist_sub=&hist_sub", "", 1)

    ; Check for duplicate option.
    &idx=string.scan("&opts", "hist_sub=", 0)
    if (&idx!=-1.)
    (
      &args_latest_error="DUP_OPT_KEY"
      return ARGS_ERR
    )
  )
  if ("&hist_cmd"!="INV_OPT")
  (
    ; Require a subroutine for the command option.
    &hist_sub=var.string(\&gvar_name_hist_sub)
    if (("&hist_cmd"!="")&&("&hist_sub"==""))
    (
      print %ERROR "ERROR [&ARGS_SCRIPT_FILE]:"
      print %ERROR "  History sub is required for history command option (hist_cmd='&hist_cmd')."

      &args_latest_error="OPT_CMD_NO_SUB"
      return ARGS_ERR
    )

    ; Start recording command history.
    if ("&hist_cmd"!="")
    (
      var.assign \&gvar_name_hist_en = 1
    )

    ; Record the client's option.
    gosub args_var_assign_string &gvar_name_hist_cmd 64. &hist_cmd
    entry &idx
    if (&idx==-1.)
    (
      &args_latest_error="LONG_OPT_CMD"
      return ARGS_ERR
    )

    ; Remove the option from the options line.
    &opts=string.replace("&opts", "hist_cmd=&hist_cmd", "", 1)

    ; Check for duplicate option.
    &idx=string.scan("&opts", "hist_cmd=", 0)
    if (&idx!=-1.)
    (
      &args_latest_error="DUP_OPT_KEY"
      return ARGS_ERR
    )
  )
  if ("&nonempty_cmds"!="INV_OPT")
  (
    ; Mandate binary 'nonempty' option.
    if (("&nonempty_cmds"!="0")&&("&nonempty_cmds"!="1"))
    (
      print %ERROR "ERROR [&ARGS_SCRIPT_FILE]:"
      print %ERROR "  Option 'nonempty_cmds' must be 1 or 0 (got '&nonempty_cmds')."

      &args_latest_error="INV_OPT_VAL"
      return ARGS_ERR
    )

    ; Record the client's option.
    var.assign \&gvar_name_nonempty_cmds = &nonempty_cmds

    ; Remove the option from the options line.
    &opts=string.replace("&opts", "nonempty_cmds=&nonempty_cmds", "", 1)

    ; Check for duplicate option.
    &idx=string.scan("&opts", "nonempty_cmds=", 0)
    if (&idx!=-1.)
    (
      &args_latest_error="DUP_OPT_KEY"
      return ARGS_ERR
    )
  )
  if ("&nonempty_vals"!="INV_OPT")
  (
    ; Mandate binary 'nonempty' option.
    if (("&nonempty_vals"!="0")&&("&nonempty_vals"!="1"))
    (
      print %ERROR "ERROR [&ARGS_SCRIPT_FILE]:"
      print %ERROR "  Option 'nonempty_vals' must be 1 or 0 (got '&nonempty_vals')."

      &args_latest_error="INV_OPT_VAL"
      return ARGS_ERR
    )

    ; Record the client's option.
    var.assign \&gvar_name_nonempty_vals = &nonempty_vals

    ; Remove the option from the options line.
    &opts=string.replace("&opts", "nonempty_vals=&nonempty_vals", "", 1)

    ; Check for duplicate option.
    &idx=string.scan("&opts", "nonempty_vals=", 0)
    if (&idx!=-1.)
    (
      &args_latest_error="DUP_OPT_KEY"
      return ARGS_ERR
    )
  )
  if ("&print_errors"!="INV_OPT")
  (
    ; Mandate binary 'nonempty' option.
    if (("&print_errors"!="0")&&("&print_errors"!="1"))
    (
      print %ERROR "ERROR [&ARGS_SCRIPT_FILE]:"
      print %ERROR "  Option 'print_errors' must be 1 or 0 (got '&print_errors')."

      &args_latest_error="INV_OPT_VAL"
      return ARGS_ERR
    )

    ; Record the client's option.
    var.assign \&gvar_name_print_errors_en = &print_errors

    ; Remove the option from the options line.
    &opts=string.replace("&opts", "print_errors=&print_errors", "", 1)

    ; Check for duplicate option.
    &idx=string.scan("&opts", "print_errors=", 0)
    if (&idx!=-1.)
    (
      &args_latest_error="DUP_OPT_KEY"
      return ARGS_ERR
    )
  )

  ;
  ; Detect unknown option keywords.
  ;
  &opts=string.trim("&opts")
  if ("&opts"!="")
  (
    &args_latest_error="INV_OPT_KEY"
    return ARGS_ERR
  )

  ;
  ; Return success.
  ;
  return
)

;-----------------------------------------------------------------------------
;
; SUB:      int args_clear_opts ( void )
;
; INFO:     Sets all ARGS options to their default disabled state.
;
; RETURNS:  Nothing upon success, else "ARGS_ERR".
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;-----------------------------------------------------------------------------
args_clear_opts:
(
  ; Clear every option.
  var.assign \&gvar_name_help_cmd[0] = 0
  var.assign \&gvar_name_help_sub[0] = 0
  var.assign \&gvar_name_hist_cmd[0] = 0
  var.assign \&gvar_name_hist_sub[0] = 0

  var.assign \&gvar_name_nonempty_cmds = 0
  var.assign \&gvar_name_nonempty_vals = 0
  var.assign \&gvar_name_print_errors_en = 0

  ;
  ; Return success.
  ;
  return
)

;-----------------------------------------------------------------------------
;
; SUB:      string args_get_arg ( [line prompt] )
;
; INFO:     Returns the next user argument, separated by spaces. Does not
;           provide special handling of keyword arguments. Only prints a
;           prompt line if all buffered arguments have been read previously.
;           Selects the client's I/O area before/after user entry prompts.
;
;           Do not wrap the 'prompt' parameter in double quotes. Note that the
;           'prompt' line will automatically be trimmed as a consequence of
;           PRACTICE parameter-passing complications.
;
; RETURNS:  "ARGS_ERR"  => Error occured.
;           <arg>       => Success.

;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID, INV_IO_AREA, LONG_CMD_LINE}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;-----------------------------------------------------------------------------
args_get_arg:
(
  local &help_cmd
  local &help_sub
  local &hist_cmd
  local &hist_sub

  local &area_name
  local &arg
  local &read_idx
  local &cmd_line
  local &idx

  local &prompt
  local &prompt_printed

  entry %LINE &prompt

args__get_arg_buffered:

  ; Read in the client's help/history/quit commands and subroutines.
  &help_cmd=var.string(\&gvar_name_help_cmd)
  &help_sub=var.string(\&gvar_name_help_sub)
  &hist_cmd=var.string(\&gvar_name_hist_cmd)
  &hist_sub=var.string(\&gvar_name_hist_sub)

  ; Read in the client's buffered command line and read position.
  &cmd_line=var.string(\&gvar_name_cmd_line)
  &read_idx=var.value(\&gvar_name_read_idx)

  &prompt_printed=0

  ;
  ; Attempt to read next argument word from the buffered command line.
  ;
  gosub args_get_next_substr_ws "&cmd_line" &read_idx
  entry &arg &read_idx

  if ("&arg"=="")
  (
    &read_idx=0

    ;
    ; Read and verify the client's I/O area.
    ;
    &area_name=var.string(\&gvar_name_area_name)
    gosub args_verify_and_select_area &area_name
    entry &args_latest_error
    if ("&args_latest_error"!="NO_ERROR")
    (
      &arg="INV_IO_AREA"

      var.assign \&gvar_name_read_idx = 0
      var.assign \&gvar_name_cmd_line[0] = 0
      return
    )

args__get_arg_user_prompt:

    ;
    ; Get the next command line from the user.
    ;
    area.select &area_name
    if (&prompt_printed==0)
    (
      if ("&prompt"!="")
      (
        print "&prompt"
      )
      &prompt_printed=1
    )
    enter %LINE &cmd_line
    area.select &area_name

    ; Read the first argument word from the new command line.
    gosub args_get_next_substr_ws "&cmd_line" 0.
    entry &arg &read_idx

    if ("&arg"=="")
    (
      &read_idx=0

      ; Apply 'nonempty' command option.
      var.if (\&gvar_name_nonempty_cmds!=0)
      (
        goto args__get_arg_user_prompt
      )
    )
    else
    (
      ; Record the new command line in history.
      var.if (\&gvar_name_hist_en!=0)
      (
        gosub args_add_hist_entry "&cmd_line"
      )
    )
  )

  ;
  ; Update the client's buffered command line and read position.
  ;
  var.assign \&gvar_name_read_idx = &read_idx
  gosub args_var_assign_string &gvar_name_cmd_line 512. &cmd_line
  entry &idx
  if (&idx==-1.)
  (
    &args_latest_error="LONG_CMD_LINE"
    return ARGS_ERR
  )

  ;
  ; Check for optional help/history/quit commands.
  ;
  if (("&help_cmd"!="")&&("&arg"=="&help_cmd"))
  (
    ; Call the help sub.
    gosub &help_sub

    ; Get the next argument.
    goto args__get_arg_buffered
  )
  else if (("&hist_cmd"!="")&&("&arg"=="&hist_cmd"))
  (
    ; Call the history sub.
    gosub &hist_sub

    ; Get the next argument.
    goto args__get_arg_buffered
  )

  return &arg
)

;-----------------------------------------------------------------------------
;
; SUB:      string[2] args_get_kwarg ( [line prompt] )
;
; INFO:     Returns the next user argument, separated by spaces. Treats any
;           argument containing '=' as a keyword argument in format "key=val".
;           Only prints a prompt line if all buffered arguments have been
;           read previously. Can be interleaved with "get_arg" commands.
;           Selects the client's I/O area before/after user entry prompts.
;
;           Do not wrap the 'prompt' parameter in double quotes. Note that the
;           'prompt' line will automatically be trimmed as a consequence of
;           PRACTICE parameter-passing complications.
;
; RETURNS:  {"ARGS_ERR"}      => A failure occured.
;           {"NO_KEY", <arg>} => A non-keyword arg was found (no '=').
;           {<key>,    <val>} => A valid keyword arg was found.
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID, INV_IO_AREA, LONG_CMD_LINE,
;           NO_KWARG_KEY, [NO_KWARG_VAL]}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;           The 'NO_KWARG_VAL' error only occurs if the "nonempty_vals" option
;           is enabled.
;
;-----------------------------------------------------------------------------
args_get_kwarg:
(
  local &val
  local &key
  local &key_temp
  local &eq_char_idx
  local &arg
  local &prompt

  entry %LINE &prompt

  ;
  ; Get the next raw argument.
  ;
  gosub args_get_arg &prompt
  entry &arg
  if ("&arg"=="ARGS_ERR")
  (
    return ARGS_ERR
  )

  &eq_char_idx=string.scan("&arg", "=", 0)

  if (&eq_char_idx==-1.)
  (
    ;
    ; Non-keyword argument detected.
    ;
    &key="NO_KEY"
    &val="&arg"
  )
  else
  (
    ;
    ; Keyword argument detected--spit it by '='.
    ;
    &val=string.cut("&arg", &eq_char_idx+1)
    &key=string.mid("&arg", 0, &eq_char_idx)
    &key_temp="&key"

    ;
    ; Require key/val pair to be adjacent to the '=' separator
    ;
    if ("&val"=="")
    (
      ; Check if the non-empty kwarg value option is enabled.
      var.if (\&gvar_name_nonempty_vals!=0)
      (
        print %ERROR "ERROR [&ARGS_SCRIPT_FILE]:"
        print %ERROR "  Expected a value just after '=' (arg: '&arg')."

        &key="ARGS_ERR"
        &val=""
        &args_latest_error="NO_KWARG_VAL"
      )
    )
    if ("&key_temp"=="")
    (
      print %ERROR "ERROR [&ARGS_SCRIPT_FILE]:"
      print %ERROR "  Expected a key just before '=' (arg: '&arg')."

      &key="ARGS_ERR"
      &val=""
      &args_latest_error="NO_KWARG_KEY"
    )
  )

  return &key &val
)

;-----------------------------------------------------------------------------
;
; SUB:      int args_get_num_unread ( void )
;
; INFO:     Scans the client's unread portion of its buffered command line,
;           counting the number of unread arguments.
;
; RETURNS:  The number of unread arguments, or "ARGS_ERR" upon failure.
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;-----------------------------------------------------------------------------
args_get_num_unread:
(
  local &count
  local &arg
  local &cmd_line
  local &read_idx

  &cmd_line=var.string(\&gvar_name_cmd_line)
  &read_idx=var.value(\&gvar_name_read_idx)

  ;
  ; Scan the unread portion of the buffered command line.
  ;
  &count=0
  while TRUE()
  (
    gosub args_get_next_substr_ws "&cmd_line" &read_idx
    entry &arg &read_idx

    if ("&arg"=="")
    (
      ;
      ; Return the number of unread buffered arguments.
      ;
      return &count
    )

    &count=&count+1
  )
)

;-----------------------------------------------------------------------------
;
; SUB:      line args_get_cmd_line ( [flag unread] )
;
; INFO:     Returns the client's buffered command line. If the 'unread' flag
;           is given, only the unread portion of the command line is returned.
;
;           Callers can use "entry %LINE" to accept the entire return line.
;
; RETURNS:  Command line or "ARGS_ERR" upon failure.
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;-----------------------------------------------------------------------------
args_get_cmd_line:
(
  local &cmd_line
  local &read_idx
  local &unread
  entry &unread

  &cmd_line=var.string(\&gvar_name_cmd_line)

  if ("&unread"!="")
  (
    &read_idx=var.value(\&gvar_name_read_idx)

    &cmd_line=string.cut("&cmd_line", &read_idx)
  )

  return &cmd_line
)

;-----------------------------------------------------------------------------
;
; SUB:      int args_print_hist ( void )
;
; INFO:     Prints each history entry to the currently selected area. The
;           oldest entry is printed at the top, with one entry per line.
;
; RETURNS:  Nothing upon success, else "ARGS_ERR".
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;-----------------------------------------------------------------------------
args_print_hist:
(
  local &age
  local &hist_entry

  &age=var.value(\&gvar_name_num_hist_entries)
  &age=&age-1

  ;
  ; Print each history entry with the oldest entry on top.
  ;
  while (&age>=0)
  (
    gosub args_get_hist_entry &age
    entry %LINE &hist_entry

    print "&hist_entry  "
    &age=&age-1
  )

  ;
  ; Return success.
  ;
  return
)

;-----------------------------------------------------------------------------
;
; SUB:      line args_get_hist_entry ( int entry_age )
;
; INFO:     Gets the selected history entry (the youngest age is 0).
;           Return value should be read with "entry %LINE".
;
; RETURNS:  The history entry line upon success, else "ARGS_ERR".
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID, INV_HIST_AGE}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;-----------------------------------------------------------------------------
args_get_hist_entry:
(
  local &entry_age
  local &hist_age
  local &hist_entry
  local &tip_idx

  entry &entry_age

  ;
  ; Validate the history entry age.
  ;
  &hist_age=var.value(\&gvar_name_num_hist_entries)
  if (&entry_age>&hist_age)
  (
    &args_latest_error="INV_HIST_AGE"
    return ARGS_ERR
  )

  ; Convert the entry age to a delta from the history tip index.
  &entry_age=(-1.-&entry_age)

  ; Get the history entry index.
  &tip_idx=var.value(\&gvar_name_hist_tip_idx)
  gosub args_get_circ_buf_idx &tip_idx &entry_age &ARGS_MAX_HIST_ENTRIES
  entry &entry_age

  ;
  ; Return the requested history entry line.
  ;
  &hist_entry=var.string(\&gvar_name_hist_buf[&entry_age])
  return &hist_entry
)

;-----------------------------------------------------------------------------
;
; SUB:      int args_get_hist_size( void )
;
; INFO:     Returns the client's number of command history entries.
;
; RETURNS:  Client's history age (the youngest age is 0), or "ARGS_ERR" upon
;           failure.
;
; ERRORS:   {NO_CLIENT_ID, INV_CLIENT_ID}.
;
; NOTES:    Client ID is pre-verified by main.
;           Client global variable names are pre-assigned by main.
;
;-----------------------------------------------------------------------------
args_get_hist_size:
(
  local &num_hist_entries

  ;
  ; Return the client's history age.
  ;
  &num_hist_entries=var.value(\&gvar_name_num_hist_entries)
  return &num_hist_entries
)



;-----------------------------------------------------------------------------
;
; SUB:      string args_get_error ( [int client_id] )
;
; INFO:     Returns the error generated by the client's previous ARGS command.
;           If no client ID is provided, the error generated by the globally-
;           previous ARGS command is returned.
;
;           See "ARGS Error Reporting:" for more information.
;
; RETURNS:  An error type string (possibly "NO_ERROR"), or "ARGS_ERR" upon
;           detecting an invalid client ID.
;
; ERRORS:   {GET_ERR_INV_ID}.
;
; NOTES:    Records the special 'GET_ERR_INV_ID' error upon failure in order
;           to trouble-shoot improper "get_error" usage.
;
;           Client ID is pre-verified by main.
;
;-----------------------------------------------------------------------------
args_get_error:
(
  local &err_str
  local &client_id

  entry &client_id

  if ("&client_id"=="")
  (
    ;
    ; Return the globally-previous error type string.
    ;
    return &args_latest_error
  )
  else
  (
    ;
    ; Return the client's previous error type string.
    ;
    gosub args_set_gvar_names &client_id
    &err_str=var.string(\&gvar_name_client_error)

    return &err_str
  )
)
